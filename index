<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rogue-2048 Prototype (Offline)</title>
<style>
  :root{
    --bg:#f0f2f5; --cell:#cdc1b4; --empty:#eee4da;
    --tile-2:#eee4da; --tile-4:#ede0c8; --tile-8:#f2b179; --tile-16:#f59563;
    --tile-32:#f67c5f; --tile-64:#f65e3b; --tile-big:#edcf72;
  }
  body{font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); margin:0; display:flex; justify-content:center; padding:24px;}
  .container{width:420px;}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;}
  h1{font-size:18px;margin:0;}
  .stats{display:flex;gap:8px;}
  .card{background:white;padding:8px 12px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.08);font-size:13px;}
  .board{background:#bbada0;padding:12px;border-radius:8px;position:relative;}
  .grid{display:grid;grid-template-columns:repeat(4,80px);grid-gap:12px;}
  .cell{width:80px;height:80px;border-radius:6px;background:var(--empty);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:22px;color:#776e65;position:relative;overflow:hidden;}
  .tile{position:absolute; width:80px;height:80px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:22px;transition:transform 120ms ease, top 120ms ease, left 120ms ease;}
  .controls{display:flex;gap:8px;margin-top:12px;}
  button{padding:8px 10px;border-radius:6px;border:0;background:#2e7d32;color:white;cursor:pointer;}
  button.ghost{background:#6d6d6d;}
  .info{margin-top:8px;font-size:13px;color:#333;}
  .bar{height:10px;background:#ddd;border-radius:6px;overflow:hidden;margin-top:6px;}
  .hp{height:100%;background:#e53935;}
  .enemyhp{height:100%;background:#8e24aa;}
  .msg{margin-top:8px;font-size:14px;}
  /* tile colors */
  .t-2{background:var(--tile-2); color:#776e65;}
  .t-4{background:var(--tile-4); color:#776e65;}
  .t-8{background:var(--tile-8); color:white;}
  .t-16{background:var(--tile-16); color:white;}
  .t-32{background:var(--tile-32); color:white;}
  .t-64{background:var(--tile-64); color:white;}
  .t-128{background:var(--tile-big); color:white; font-size:20px;}
  .t-256{background:#f2a541; color:white; font-size:20px;}
  .t-512{background:#e27c3f; color:white; font-size:18px;}
  .t-1024{background:#e05555; color:white; font-size:16px;}
  .t-2048{background:#3c9; color:white; font-size:16px;}
  .small{font-size:12px;}
  .center{display:flex;justify-content:center;}
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Rogue-2048 (Prototype)</h1>
      <div class="stats">
        <div class="card">Score: <span id="score">0</span></div>
        <div class="card">Best: <span id="best">0</span></div>
      </div>
    </header>

    <div class="card" style="margin-bottom:12px;">
      <div style="display:flex;gap:10px;align-items:center;">
        <div>
          Player HP: <strong id="playerHP">10</strong>
          <div class="bar" style="width:140px;"><div id="playerHPbar" class="hp" style="width:100%"></div></div>
        </div>
        <div>
          Enemy HP: <strong id="enemyHP">50</strong>
          <div class="bar" style="width:140px;"><div id="enemyHPbar" class="enemyhp" style="width:100%"></div></div>
        </div>
      </div>
      <div class="info small">Note: Merging tiles deals damage to the enemy (merged value ÷ 8). The enemy attacks every 5 moves.</div>
    </div>

    <div class="board">
      <div class="grid" id="grid">
        </div>
    </div>

    <div class="controls">
      <button id="btnRestart">Restart</button>
      <button id="btnUndo" class="ghost">Undo (1 Move)</button>
      <button id="btnHint" class="ghost">Hint</button>
    </div>

    <div class="msg" id="message">Use arrow keys to move (← ↑ → ↓).</div>
    <div class="center small">
      <div style="margin-top:8px;">Moves: <span id="moves">0</span></div>
    </div>
  </div>

<script>
/*
  Rogue-2048 Prototype (Simplified implementation)
  - 4x4 2048 core logic
  - Merging deals damage to the enemy (mergedValue / DAMAGE_DIV)
  - The enemy attacks the player every MOVE_TO_HIT moves
  - Simple undo (saving the last state)
*/

const SIZE = 4;
const DAMAGE_DIV = 8;      // mergedValue / DAMAGE_DIV = damage dealt to enemy (floored)
const MOVE_TO_HIT = 5;     // enemy attacks every N moves
const PLAYER_MAX_HP = 10;
const ENEMY_MAX_HP = 50;

let grid = [];      // 2D array
let score = 0;
let best = parseInt(localStorage.getItem('rogue2048_best') || '0');
let playerHP = PLAYER_MAX_HP;
let enemyHP = ENEMY_MAX_HP;
let moves = 0;
let lastState = null; // for undo (saves a simple state)

// DOM elements
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const playerHPEl = document.getElementById('playerHP');
const enemyHPEl = document.getElementById('enemyHP');
const playerBar = document.getElementById('playerHPbar');
const enemyBar = document.getElementById('enemyHPbar');
const messageEl = document.getElementById('message');
const movesEl = document.getElementById('moves');

bestEl.textContent = best;

// Initialize DOM cells
for (let i=0;i<SIZE*SIZE;i++){
  const div = document.createElement('div');
  div.className = 'cell';
  gridEl.appendChild(div);
}

// Game initialization
function init(){
  grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(0));
  score = 0;
  playerHP = PLAYER_MAX_HP;
  enemyHP = ENEMY_MAX_HP;
  moves = 0;
  lastState = null;
  spawnRandom();
  spawnRandom();
  render();
  setMessage('Use arrow keys to move (← ↑ → ↓). Merge tiles to deal damage, but watch your HP!');
}

// Spawn a random 2 or 4 tile
function spawnRandom(){
  const empties = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (grid[r][c]===0) empties.push([r,c]);
  if (!empties.length) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  grid[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}

// Render the game state to the DOM
function render(){
  // Clear tiles (simplified: render text inside cells)
  const cells = document.querySelectorAll('.cell');
  cells.forEach((cell,i)=>{
    const r = Math.floor(i/SIZE), c = i%SIZE;
    const v = grid[r][c];
    cell.textContent = v===0 ? '' : v;
    // set style class
    cell.className = 'cell' + (v ? ' t-' + v : '');
  });

  scoreEl.textContent = score;
  playerHPEl.textContent = playerHP;
  enemyHPEl.textContent = enemyHP;
  bestEl.textContent = best;
  movesEl.textContent = moves;
  playerBar.style.width = Math.max(0,(playerHP/PLAYER_MAX_HP)*100) + '%';
  enemyBar.style.width = Math.max(0,(enemyHP/ENEMY_MAX_HP)*100) + '%';
}

// Deep copy state (for undo)
function copyState(){
  return {
    grid: grid.map(row=>row.slice()),
    score, playerHP, enemyHP, moves
  };
}

// Restore state
function restoreState(s){
  grid = s.grid.map(row=>row.slice());
  score = s.score;
  playerHP = s.playerHP;
  enemyHP = s.enemyHP;
  moves = s.moves;
  render();
}

// Check if a move is possible
function canMove(){
  // Check for empty cells
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (grid[r][c]===0) return true;
  // Check for adjacent same-value cells
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++){
    const v = grid[r][c];
    if (r+1<SIZE && grid[r+1][c]===v) return true;
    if (c+1<SIZE && grid[r][c+1]===v) return true;
  }
  return false;
}

// Move (0:left, 1:up, 2:right, 3:down)
function move(dir){
  // Save state for undo
  lastState = copyState();

  let moved = false;
  let damageThisMove = 0; // Accumulate damage for this move
  // Normalize move logic to "left" by rotating the grid
  function rotate90(g){ // 90 degrees clockwise
    const n = g.length;
    const ng = Array.from({length:n}, ()=>Array(n).fill(0));
    for (let i=0;i<n;i++) for (let j=0;j<n;j++) ng[j][n-1-i] = g[i][j];
    return ng;
  }
  let times = 0;
  if (dir === 0) times = 0; // left
  if (dir === 1) times = 1; // up -> rotate 90
  if (dir === 2) times = 2; // right
  if (dir === 3) times = 3; // down -> rotate 270
  let g = grid.map(r=>r.slice());
  for (let t=0;t<times;t++) g = rotate90(g);

  // left compress+merge per row
  for (let r=0;r<SIZE;r++){
    let row = g[r].filter(v=>v!==0);
    for (let i=0;i<row.length-1;i++){
      if (row[i] === row[i+1]){
        const merged = row[i]*2;
        row[i] = merged;
        row.splice(i+1,1);
        score += merged;
        damageThisMove += Math.floor(merged / DAMAGE_DIV);
      }
    }
    while (row.length < SIZE) row.push(0);
    // check if a move occurred
    for (let c=0;c<SIZE;c++){
      if (g[r][c] !== row[c]) moved = true;
      g[r][c] = row[c];
    }
  }

  // rotate back
  for (let t=0;t<(4-times)%4;t++) g = rotate90(g);

  if (!moved) {
    setMessage('No move occurred. Try a different direction.');
    return;
  }

  grid = g.map(r=>r.slice());
  // Deal damage
  if (damageThisMove>0){
    enemyHP -= damageThisMove;
    setMessage('You dealt ' + damageThisMove + ' damage!');
  } else {
    setMessage('Move successful, but no merge occurred (no damage).');
  }
  // Update high score
  if (score > best){ best = score; localStorage.setItem('rogue2048_best', best); }
  // Spawn a new tile
  spawnRandom();
  moves++;
  // Enemy attack cadence
  if (moves % MOVE_TO_HIT === 0){
    enemyAttack();
  }
  render();
  checkEnd();
}

// Enemy attack
function enemyAttack(){
  const dmg = Math.max(1, Math.floor( (1 + Math.log1p(moves))/1 )); // simple damage scaling with moves
  playerHP -= dmg;
  setMessage('The enemy attacks, dealing ' + dmg + ' damage!');
}

// Check for game end conditions
function checkEnd(){
  if (enemyHP <= 0){
    setMessage('You defeated the enemy! Victory! (You can restart)');
    score += enemyHP<=0 ? 100 : 0;
    if (score > best){ best = score; localStorage.setItem('rogue2048_best', best); }
    render();
    return;
  }
  if (playerHP <= 0){
    setMessage('You were defeated by the enemy, Game Over. Press "Restart" to try again.');
    render();
    return;
  }
  if (!canMove()){
    setMessage('No more moves possible, Game Over (Draw/Loss).');
    return;
  }
}

// Key event listener
window.addEventListener('keydown', (e)=>{
  if (['ArrowLeft','ArrowUp','ArrowRight','ArrowDown'].includes(e.key)){
    e.preventDefault();
    const map = {ArrowLeft:0, ArrowUp:1, ArrowRight:2, ArrowDown:3};
    move(map[e.key]);
  }
});

// Control buttons
document.getElementById('btnRestart').addEventListener('click', ()=>init());
document.getElementById('btnUndo').addEventListener('click', ()=>{
  if (lastState){ restoreState(lastState); lastState = null; setMessage('Undid one move.'); }
  else setMessage('No moves to undo.');
});
document.getElementById('btnHint').addEventListener('click', ()=>{
  setMessage('Hint: Focus on merging higher value tiles, and try to keep one side clear for easy movement.');
});

// Display message
function setMessage(txt){
  messageEl.textContent = txt;
}

// Start the game
init();

</script>
</body>
</html>
