<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Rogue-2048 â€” Roguelike Mode</title>
<style>
:root {
  --bg-start: #e0f7fa;
  --bg-end: #f5fcfd;
  --panel: #ffffff;
  --muted: #607d8b;
  --board: #b2ebf2;
  --cell-empty: #e0f2f1;
  --accent: #00bcd4;
  --accent-2: #3f51b5;
  --radius: 12px;
}
* {
  box-sizing: border-box;
}
html, body {
  height: 100%;
  margin: 0;
  font-family: 'Poppins', sans-serif, "Segoe UI", Roboto, Arial;
  background: linear-gradient(180deg, var(--bg-start), var(--bg-end));
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 20px 10px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overscroll-behavior-y: none;
  font-weight: 500;
}
.container {
  width: 100%;
  max-width: 460px;
}
header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
}
h1 {
  font-size: 24px;
  margin: 0;
  color: #212121;
  font-weight: 700;
  letter-spacing: -0.5px;
}
.stats {
  display: flex;
  gap: 8px;
  align-items: center;
}
.card {
  background: var(--panel);
  padding: 8px 16px;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(17,24,39,0.06);
  font-size: 14px;
  color: #424242;
  min-width: 90px;
  text-align: center;
  font-weight: 600;
}
.board {
  background: var(--board);
  padding: 16px;
  border-radius: 20px;
  display: flex;
  justify-content: center;
  box-shadow: 0 12px 40px rgba(17,24,39,0.08);
}
.grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  width: 100%;
  max-width: 400px;
  padding: 8px;
}
.cell {
  aspect-ratio: 1 / 1;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 30px;
  color: #424242;
  background: var(--cell-empty);
  user-select: none;
  transition: all 0.2s ease;
  transform: scale(1);
  box-shadow: inset 0 -3px 0 rgba(0,0,0,0.04), 0 2px 4px rgba(0,0,0,0.02);
}
.cell.merged {
  animation: pop 0.1s ease-in-out;
}
@keyframes pop {
  0% {transform: scale(1);}
  50% {transform: scale(1.1);}
  100% {transform: scale(1);}
}
.t-2 {background: #eee4da; color: #776e65;}
.t-4 {background: #ede0c8; color: #776e65;}
.t-8 {background: #f2b179; color: #fff;}
.t-16 {background: #f59563; color: #fff;}
.t-32 {background: #f67c5f; color: #fff;}
.t-64 {background: #f65e3b; color: #fff;}
.t-128 {background: #edcf72; color: #fff; font-size: 24px;}
.t-256 {background: #edcc61; color: #fff; font-size: 24px;}
.t-512 {background: #edc850; color: #fff; font-size: 20px;}
.t-1024 {background: #edc53f; color: #fff; font-size: 18px;}
.t-2048 {background: #edc22e; color: #fff; font-size: 18px;}
.t-large {font-size: 20px;}
.controls {
  display: flex;
  gap: 10px;
  margin-top: 16px;
}
button {
  padding: 12px 16px;
  border-radius: 12px;
  border: 0;
  cursor: pointer;
  font-weight: 700;
  font-size: 15px;
  transition: transform 0.1s ease, box-shadow 0.1s ease;
}
button:active {
  transform: translateY(2px);
  box-shadow: none;
}
#btnRestart {
  background: var(--accent-2);
  color: white;
  flex: 1;
  box-shadow: 0 4px 12px rgba(63,81,181,0.3);
}
.overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.4);
  z-index: 50;
  backdrop-filter: blur(5px);
}
.panel {
  background: var(--panel);
  padding: 24px;
  border-radius: 16px;
  min-width: 340px;
  max-width: 92%;
  box-shadow: 0 18px 60px rgba(0,0,0,0.15);
  text-align: center;
}
.panel h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 700;
  color: #212121;
}
.panel p {
  margin: 10px 0 0;
  color: var(--muted);
  font-size: 15px;
}
.event-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 20px;
}
.event-option {
  background: #f8f9fa;
  padding: 16px;
  border-radius: 12px;
  border: 1px solid #e9ecef;
  text-align: left;
  cursor: pointer;
  transition: transform .1s ease, box-shadow .1s ease;
  user-select: none;
}
.event-option:hover {
  transform: translateY(-3px);
  box-shadow: 0 12px 30px rgba(63,81,181,0.08);
}
.event-option strong {
  color: #3f51b5;
  font-size: 16px;
}
.event-option div {
  margin-top: 4px;
  font-size: 13px;
  color: #607d8b;
}
@media (max-width: 420px) {
  .grid {
    gap: 12px;
  }
  .cell {
    font-size: 26px;
  }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Rogue-2048</h1>
    <div class="stats">
      <div class="card">Score: <span id="score">0</span></div>
      <div class="card">Best: <span id="best">0</span></div>
    </div>
  </header>
  <main class="board">
    <div id="grid" class="grid"></div>
  </main>
  <div class="controls">
    <button id="btnRestart">Restart</button>
  </div>
</div>

<div id="endgameOverlay" class="overlay">
  <div class="panel">
    <h2 id="overlayTitle"></h2>
    <p id="overlayText"></p>
    <button id="btnRestart2">Restart</button>
  </div>
</div>

<div id="eventOverlay" class="overlay">
  <div class="panel">
    <h2 id="overlayTitleEvent">Event</h2>
    <p id="overlayTextEvent"></p>
    <div id="eventOptions" class="event-options"></div>
    <button id="btnCloseEvent">Close</button>
  </div>
</div>

<script>
const SIZE = 4;
let grid = [];
let score = 0;
let best = parseInt(localStorage.getItem('rogue2048_best_roguelike') || '0');
let moves = 0;
let gameOver = false;
let isEventActive = false;
let triggeredMultiples = new Set();
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const endgameOverlay = document.getElementById('endgameOverlay');
const eventOverlay = document.getElementById('eventOverlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');
const eventOptionsEl = document.getElementById('eventOptions');
const overlayTitleEvent = document.getElementById('overlayTitleEvent');
const overlayTextEvent = document.getElementById('overlayTextEvent');

bestEl.textContent = best;
let blindMode = false;

function createGridUI() {
  gridEl.innerHTML = '';
  for (let i = 0; i < SIZE * SIZE; i++) {
    const div = document.createElement('div');
    div.className = 'cell';
    gridEl.appendChild(div);
  }
}

function render() {
  const cells = document.querySelectorAll('.cell');
  let maxV = 0;
  let minV = Infinity;
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      const v = grid[r][c];
      if (v !== 0) {
        if (v > maxV) maxV = v;
        if (v < minV) minV = v;
      }
    }
  }
  if (minV === Infinity) minV = 0;

  cells.forEach((cell, i) => {
    const r = Math.floor(i / SIZE), c = i % SIZE;
    const v = grid[r][c];
    if (blindMode && v !== 0) {
      cell.textContent = '?';
      cell.className = 'cell t-large';
    } else {
      cell.textContent = v === 0 ? '' : v;
      cell.className = 'cell' + (v ? ' t-' + v : '');
      if (v >= 1024) cell.classList.add('t-large');
    }
  });
  scoreEl.textContent = score;
  bestEl.textContent = best;

  if (!isEventActive && maxV >= 8 && maxV % 8 === 0 && !triggeredMultiples.has(maxV)) {
    triggeredMultiples.add(maxV);
    showEvent(maxV);
  }
}

function init() {
  createGridUI();
  grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  score = 0; moves = 0; gameOver = false; isEventActive = false;
  triggeredMultiples.clear();
  blindMode = false;
  spawnRandom();
  spawnRandom();
  render();
  hideOverlays();
  enableInput();
}

function spawnRandom() {
  const empties = [];
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (grid[r][c] === 0) empties.push([r, c]);
    }
  }
  if (!empties.length) return false;
  const [r, c] = empties[Math.floor(Math.random() * empties.length)];
  grid[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}

function cloneGrid(g) {
  return g.map(row => row.slice());
}

function moveLeftProcess(g) {
  let moved = false;
  let gained = 0;
  const ng = g.map(row => {
    const filtered = row.filter(x => x !== 0);
    const newRow = [];
    for (let i = 0; i < filtered.length; i++) {
      if (i + 1 < filtered.length && filtered[i] === filtered[i + 1]) {
        const merged = filtered[i] * 2;
        newRow.push(merged);
        gained += merged;
        i++;
      } else {
        newRow.push(filtered[i]);
      }
    }
    while (newRow.length < SIZE) newRow.push(0);
    return newRow;
  });
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (ng[r][c] !== g[r][c]) moved = true;
    }
  }
  return { newGrid: ng, moved, gained };
}

function transpose(g) {
  const ng = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  for (let i = 0; i < SIZE; i++) for (let j = 0; j < SIZE; j++) ng[i][j] = g[j][i];
  return ng;
}

function reverseRows(g) {
  return g.map(row => row.slice().reverse());
}

function move(dir) {
  if (gameOver || isEventActive) return;
  let g = cloneGrid(grid);
  let result;

  switch (dir) {
    case 0:
      result = moveLeftProcess(g);
      g = result.newGrid;
      break;
    case 3:
      g = transpose(g);
      result = moveLeftProcess(g);
      g = transpose(result.newGrid);
      break;
    case 2:
      g = reverseRows(g);
      result = moveLeftProcess(g);
      g = reverseRows(result.newGrid);
      break;
    case 1:
      g = transpose(g);
      g = reverseRows(g);
      result = moveLeftProcess(g);
      g = reverseRows(result.newGrid);
      g = transpose(g);
      break;
  }

  if (!result || !result.moved) return;

  grid = g.map(r => r.slice());
  score += result.gained;
  if (score > best) {
    best = score;
    localStorage.setItem('rogue2048_best_roguelike', best);
  }
  blindMode = false;
  spawnRandom();
  moves++;
  render();
  checkEnd();
}

function canMove() {
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (grid[r][c] === 0) return true;
      if (r + 1 < SIZE && grid[r + 1][c] === grid[r][c]) return true;
      if (c + 1 < SIZE && grid[r][c + 1] === grid[r][c]) return true;
    }
  }
  return false;
}

function checkEnd() {
  if (!canMove()) {
    endGame('Game Over', `You scored ${score} points in ${moves} moves.`);
  }
}

function endGame(title, text) {
  gameOver = true;
  disableInput();
  if (score > best) {
    best = score;
    localStorage.setItem('rogue2048_best_roguelike', best);
  }
  overlayTitle.textContent = title;
  overlayText.textContent = text + ` (Best: ${best})`;
  endgameOverlay.style.display = 'flex';
}

function showEvent(triggerValue) {
  isEventActive = true;
  disableInput();
  overlayTitleEvent.textContent = 'Event Triggered!';
  overlayTextEvent.textContent = `Your max tile is ${triggerValue}. Choose your fate:`;
  eventOptionsEl.innerHTML = '';

  // Helpers for event actions:
  function getMaxTile() {
    let maxTile = 0;
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        if (grid[r][c] > maxTile) maxTile = grid[r][c];
      }
    }
    return maxTile;
  }
  function getMinTile() {
    let minTile = Infinity;
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        const val = grid[r][c];
        if (val !== 0 && val < minTile) minTile = val;
      }
    }
    return minTile === Infinity ? 0 : minTile;
  }
  function getTilesWithValues(arr) {
    const positions = [];
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        if (arr.includes(grid[r][c])) positions.push([r, c]);
      }
    }
    return positions;
  }
  function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  // Define events categories:
  const goodEvents = [
    {
      text: 'Add one tile equal to current max tile',
      action: () => {
        const maxTile = getMaxTile();
        const empties = getTilesWithValues([0]);
        if (empties.length) {
          const [r, c] = empties[Math.floor(Math.random() * empties.length)];
          grid[r][c] = maxTile;
          render();
        }
      }
    },
    {
      text: 'Double all tiles that are 2, 4, or 8 (random choice)',
      action: () => {
        const candidates = [2,4,8];
        const chosen = candidates[Math.floor(Math.random() * candidates.length)];
        for (let r=0; r<SIZE; r++) {
          for (let c=0; c<SIZE; c++) {
            if (grid[r][c] === chosen) grid[r][c] = grid[r][c]*2;
          }
        }
        render();
      }
    }
  ];

  const badEvents = [
    {
      text: 'Halve the maximum tile (floor division)',
      action: () => {
        const maxTile = getMaxTile();
        for (let r=0; r<SIZE; r++) {
          for (let c=0; c<SIZE; c++) {
            if (grid[r][c] === maxTile) grid[r][c] = Math.floor(grid[r][c] / 2);
          }
        }
        render();
      }
    },
    {
      text: 'Halve all tiles that are 4, 8, or 16 (floor division)',
      action: () => {
        const candidates = [4,8,16];
        for (let r=0; r<SIZE; r++) {
          for (let c=0; c<SIZE; c++) {
            if (candidates.includes(grid[r][c])) {
              grid[r][c] = Math.floor(grid[r][c]/2);
            }
          }
        }
        render();
      }
    }
  ];

  const chaosEvents = [
    {
      text: 'Shuffle all tiles',
      action: () => {
        const flat = [];
        for (let r=0; r<SIZE; r++) for (let c=0; c<SIZE; c++) flat.push(grid[r][c]);
        shuffleArray(flat);
        for (let i=0; i<SIZE*SIZE; i++) grid[Math.floor(i/SIZE)][i%SIZE] = flat[i];
        render();
      }
    },
    {
      text: 'Blind mode (hide all tiles with "?")',
      action: () => {
        blindMode = true;
        render();
      }
    },
    {
      text: 'Set all tiles to the maximum tile',
      action: () => {
        const maxTile = getMaxTile();
        for (let r=0; r<SIZE; r++) for (let c=0; c<SIZE; c++) grid[r][c] = maxTile;
        render();
      }
    },
    {
      text: 'Set all tiles to the minimum tile (excluding zero)',
      action: () => {
        const minTile = getMinTile();
        for (let r=0; r<SIZE; r++) for (let c=0; c<SIZE; c++) grid[r][c] = minTile;
        render();
      }
    },
    {
      text: 'Get one tile set to 2048',
      action: () => {
        const empties = getTilesWithValues([0]);
        if (empties.length) {
          const [r, c] = empties[Math.floor(Math.random() * empties.length)];
          grid[r][c] = 2048;
        } else {
          // if no empty, replace a random tile
          const allPositions = [];
          for (let r=0; r<SIZE; r++) for (let c=0; c<SIZE; c++) allPositions.push([r,c]);
          const [r,c] = allPositions[Math.floor(Math.random()*allPositions.length)];
          grid[r][c] = 2048;
        }
        render();
      }
    },
    {
      text: 'Randomly multiply all tiles by 0.25, 0.5, 2, or 4',
      action: () => {
        const factors = [0.25, 0.5, 2, 4];
        const factor = factors[Math.floor(Math.random() * factors.length)];
        for (let r=0; r<SIZE; r++) {
          for (let c=0; c<SIZE; c++) {
            if(grid[r][c] !== 0){
              grid[r][c] = Math.max(1, Math.floor(grid[r][c] * factor));
            }
          }
        }
        render();
      }
    },
    {
      text: 'Easter egg: nothing happens',
      action: () => {
        // no changes
      }
    }
  ];

  // Pick good or bad randomly for auto events
  // Chaos is only via user choice in event options

  // If max tile is divisible by 8 and not triggered before, show event

  // Create buttons for all three categories

  // Good and Bad pick one random effect each for display text, but allow user to pick too? 
  // Your idea said chaos is selectable, so show all 7 chaos options.

  // Let's do: Good and Bad random pick one effect each and display text, user confirms by clicking
  // Chaos will show all options for user to pick one.

  // Build event options:

  // First add good event random pick
  const goodEvent = goodEvents[Math.floor(Math.random() * goodEvents.length)];
  const badEvent = badEvents[Math.floor(Math.random() * badEvents.length)];

  // Create Good option button
  const goodBtn = document.createElement('div');
  goodBtn.className = 'event-option';
  goodBtn.innerHTML = `<strong>Good Effect:</strong><br>${goodEvent.text}`;
  goodBtn.onclick = () => {
    goodEvent.action();
    closeEvent();
  };
  eventOptionsEl.appendChild(goodBtn);

  // Create Bad option button
  const badBtn = document.createElement('div');
  badBtn.className = 'event-option';
  badBtn.innerHTML = `<strong>Bad Effect:</strong><br>${badEvent.text}`;
  badBtn.onclick = () => {
    badEvent.action();
    closeEvent();
  };
  eventOptionsEl.appendChild(badBtn);

  // Create Chaos option buttons for all chaosEvents:
  chaosEvents.forEach((ev, idx) => {
    const chaosBtn = document.createElement('div');
    chaosBtn.className = 'event-option';
    chaosBtn.innerHTML = `<strong>Chaos Option ${idx+1}:</strong><br>${ev.text}`;
    chaosBtn.onclick = () => {
      ev.action();
      closeEvent();
    };
    eventOptionsEl.appendChild(chaosBtn);
  });

  eventOverlay.style.display = 'flex';
}

function closeEvent() {
  isEventActive = false;
  blindMode = false;
  eventOverlay.style.display = 'none';
  enableInput();
  render();
}

function disableInput() {
  window.removeEventListener('keydown', keyHandler);
  window.removeEventListener('touchstart', touchStartHandler, { passive: true });
  window.removeEventListener('touchmove', touchMoveHandler, { passive: true });
  window.removeEventListener('touchend', touchEndHandler, { passive: true });
}

function enableInput() {
  window.addEventListener('keydown', keyHandler);
  window.addEventListener('touchstart', touchStartHandler, { passive: true });
  window.addEventListener('touchmove', touchMoveHandler, { passive: true });
  window.addEventListener('touchend', touchEndHandler, { passive: true });
}

function keyHandler(e) {
  if (gameOver || isEventActive) return;
  switch(e.key) {
    case 'ArrowLeft': move(0); break;
    case 'ArrowDown': move(1); break;
    case 'ArrowRight': move(2); break;
    case 'ArrowUp': move(3); break;
  }
}

let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

function touchStartHandler(e) {
  if (gameOver || isEventActive) return;
  if (e.touches.length === 1) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchEndX = touchStartX;
    touchEndY = touchStartY;
  }
}
function touchMoveHandler(e) {
  if (gameOver || isEventActive) return;
  if (e.touches.length === 1) {
    touchEndX = e.touches[0].clientX;
    touchEndY = e.touches[0].clientY;
  }
}
function touchEndHandler(e) {
  if (gameOver || isEventActive) return;
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx < 30 && absDy < 30) return;

  if (absDx > absDy) {
    if (dx > 0) move(2);
    else move(0);
  } else {
    if (dy > 0) move(1);
    else move(3);
  }

  touchStartX = 0;
  touchStartY = 0;
  touchEndX = 0;
  touchEndY = 0;
}

document.getElementById('btnRestart').addEventListener('click', () => {
  init();
  endgameOverlay.style.display = 'none';
});
document.getElementById('btnRestart2').addEventListener('click', () => {
  init();
  endgameOverlay.style.display = 'none';
});
document.getElementById('btnCloseEvent').addEventListener('click', () => {
  closeEvent();
});

init();
</script>
</body>
</html>
