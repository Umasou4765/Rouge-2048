<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rogue-2048 - Roguelike</title>
<style>
  :root{
    --bg:#f0f2f5; --cell:#cdc1b4; --empty:#eee4da;
    --tile-2:#eee4da; --tile-4:#ede0c8; --tile-8:#f2b179; --tile-16:#f59563;
    --tile-32:#f67c5f; --tile-64:#f65e3b; --tile-big:#edcf72;
  }
  *{box-sizing:border-box}
  body{font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial; background:var(--bg); margin:0; display:flex; justify-content:center; padding:24px;}
  .container{width:460px;}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;}
  h1{font-size:18px;margin:0;}
  .stats{display:flex;gap:8px;}
  .card{background:white;padding:8px 12px;border-radius:8px;box-shadow:0 2px 6px rgba(0,0,0,0.08);font-size:13px;}
  .board{background:#bbada0;padding:12px;border-radius:8px;position:relative;}
  .grid{display:grid;grid-template-columns:repeat(4,86px);grid-gap:12px; padding:6px;}
  .cell{width:86px;height:86px;border-radius:6px;background:var(--empty);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:26px;color:#776e65;position:relative;overflow:hidden;}
  .controls{display:flex;gap:8px;margin-top:12px;}
  button{padding:8px 10px;border-radius:6px;border:0;background:#2e7d32;color:white;cursor:pointer;flex:1;}
  button.ghost{background:#6d6d6d;color:#fff;}
  .info{margin-top:8px;font-size:13px;color:#333;}
  .bar{height:10px;background:#ddd;border-radius:6px;overflow:hidden;margin-top:6px;}
  .hp{height:100%;background:#e53935;}
  .msg{margin-top:8px;font-size:14px;}
  .small{font-size:12px;}
  .center{display:flex;justify-content:center;}
  /* tile colors */
  .t-2{background:var(--tile-2); color:#776e65;}
  .t-4{background:var(--tile-4); color:#776e65;}
  .t-8{background:var(--tile-8); color:white;}
  .t-16{background:var(--tile-16); color:white;}
  .t-32{background:var(--tile-32); color:white;}
  .t-64{background:var(--tile-64); color:white;}
  .t-128{background:var(--tile-big); color:white; font-size:20px;}
  .t-256{background:#f2a541; color:white; font-size:20px;}
  .t-512{background:#e27c3f; color:white; font-size:18px;}
  .t-1024{background:#e05555; color:white; font-size:16px;}
  .t-2048{background:#3c9; color:white; font-size:16px;}
  .t-4096{background:#0a854d; color:white; font-size:16px;}
  .t-8192{background:#004d3c; color:white; font-size:16px;}
  /* overlay */
  .overlay{
    position:fixed; inset:0; display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,0.45); z-index:50; display:none;
  }
  .overlay .panel{background:#fff;padding:20px;border-radius:10px;text-align:center;min-width:300px; max-width: 90%;}
  .overlay h2{margin:0 0 8px 0;}
  .meta{font-size:13px;color:#666;margin-top:6px;}
  .event-options{display:flex;flex-direction:column;gap:10px;margin-top:16px;}
  .event-option{
    background:#f0f2f5;
    padding:12px;
    border-radius:8px;
    border:1px solid #ddd;
    text-align:left;
    cursor:pointer;
    transition:transform 0.1s;
  }
  .event-option:hover{transform:scale(1.02);}
  .event-option h3{margin:0;font-size:16px;}
  .event-option p{margin:4px 0 0;font-size:12px;color:#666;}
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Rogue-2048 - Roguelike Mode</h1>
      <div class="stats">
        <div class="card">Score: <span id="score">0</span></div>
        <div class="card">Best: <span id="best">0</span></div>
      </div>
    </header>

    <div class="card" style="margin-bottom:12px;">
      <div class="info small">Welcome to Roguelike Mode. Merge tiles to score points. When your highest tile reaches a certain value, a random event will trigger.</div>
    </div>

    <div class="board" id="board">
      <div class="grid" id="grid"></div>
    </div>

    <div class="controls">
      <button id="btnRestart">Restart</button>
      <button id="btnUndo" class="ghost">Undo</button>
    </div>

    <div class="msg" id="message">Use arrow keys (← ↑ → ↓) to move.</div>
    <div class="center small" style="margin-top:8px;">
      <div>Moves: <span id="moves">0</span></div>
    </div>
  </div>

  <div class="overlay" id="endgameOverlay">
    <div class="panel">
      <h2 id="overlayTitle">Game Over</h2>
      <div id="overlayText" class="meta">You scored X points and made Y moves.</div>
      <div style="margin-top:14px;">
        <button id="overlayRestart">Restart</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="eventOverlay">
    <div class="panel">
      <h2>Event Triggered!</h2>
      <p id="eventMessage" class="meta">Your highest tile reached <span id="eventTriggerValue">X</span>. Choose an option:</p>
      <div class="event-options" id="eventOptions">
        </div>
    </div>
  </div>

<script>
// --- Game Constants ---
const SIZE = 4;
const EVENT_THRESHOLDS = [8, 128, 2048, 8192, 32768, 131072]; // Highest tile values to trigger an event

let grid = [];
let score = 0;
let best = parseInt(localStorage.getItem('rogue2048_best_roguelike') || '0');
let moves = 0;
let lastState = null;
let gameOver = false;
let maxTileValue = 0;
let triggeredThresholds = new Set();
let isEventActive = false;

// --- DOM Elements ---
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const messageEl = document.getElementById('message');
const movesEl = document.getElementById('moves');
const endgameOverlay = document.getElementById('endgameOverlay');
const eventOverlay = document.getElementById('eventOverlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');
const eventMessageEl = document.getElementById('eventMessage');
const eventOptionsEl = document.getElementById('eventOptions');
const eventTriggerValueEl = document.getElementById('eventTriggerValue');

bestEl.textContent = best;

// --- Core Game Logic ---

function init(){
  gridEl.innerHTML = '';
  for (let i=0;i<SIZE*SIZE;i++){
    const div = document.createElement('div');
    div.className = 'cell';
    gridEl.appendChild(div);
  }
  grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(0));
  score = 0;
  moves = 0;
  lastState = null;
  gameOver = false;
  maxTileValue = 0;
  triggeredThresholds = new Set();
  isEventActive = false;

  spawnRandom();
  spawnRandom();
  render();
  setMessage('Use arrow keys (← ↑ → ↓) to move.');
  hideOverlays();
  enableInput();
}

function spawnRandom(){
  const empties = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (grid[r][c]===0) empties.push([r,c]);
  if (!empties.length) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  grid[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}

function render(){
  const cells = document.querySelectorAll('.cell');
  maxTileValue = 0;
  cells.forEach((cell,i)=>{
    const r = Math.floor(i/SIZE), c = i%SIZE;
    const v = grid[r][c];

    cell.textContent = v===0 ? '' : v;
    cell.className = 'cell' + (v ? ' t-' + v : '');
    if (v > maxTileValue) maxTileValue = v;
  });
  scoreEl.textContent = score;
  bestEl.textContent = best;
  movesEl.textContent = moves;
  
  // Check for event trigger
  if (!isEventActive && EVENT_THRESHOLDS.includes(maxTileValue) && !triggeredThresholds.has(maxTileValue)){
    triggeredThresholds.add(maxTileValue);
    showEvent(maxTileValue);
  }
}

function copyState(){
  return {
    grid: grid.map(r=>r.slice()),
    score, moves, maxTileValue
  };
}

function restoreState(s){
  grid = s.grid.map(r=>r.slice());
  score = s.score;
  moves = s.moves;
  maxTileValue = s.maxTileValue;
  render();
}

function canMove(){
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      if (grid[r][c]===0) return true;
      if (r+1<SIZE && grid[r+1][c]===grid[r][c]) return true;
      if (c+1<SIZE && grid[r][c+1]===grid[r][c]) return true;
    }
  }
  return false;
}

function rotate90(g){
  const n = g.length;
  const ng = Array.from({length:n}, ()=>Array(n).fill(0));
  for (let i=0;i<n;i++) for (let j=0;j<n;j++) ng[j][n-1-i] = g[i][j];
  return ng;
}

function move(dir){
  if (gameOver || isEventActive) return;
  lastState = copyState();

  let times = dir % 4;
  let g = grid.map(r=>r.slice());
  for (let t=0;t<times;t++) g = rotate90(g);

  let moved = false;
  for (let r=0;r<SIZE;r++){
    const row = g[r].filter(v=>v!==0);
    const newRow = [];
    let skip = false;
    for (let i=0;i<row.length;i++){
      if (skip){ skip = false; continue; }
      if (i+1 < row.length && row[i] === row[i+1]){
        const merged = row[i] * 2;
        newRow.push(merged);
        score += merged;
        skip = true;
      } else {
        newRow.push(row[i]);
      }
    }
    while (newRow.length < SIZE) newRow.push(0);
    for (let c=0;c<SIZE;c++){
      if (g[r][c] !== newRow[c]) moved = true;
      g[r][c] = newRow[c];
    }
  }

  for (let t=0;t<(4-times)%4;t++) g = rotate90(g);

  if (!moved){
    setMessage('No move possible, try a different direction.');
    return;
  }
  
  grid = g.map(r=>r.slice());
  if (score > best){ best = score; localStorage.setItem('rogue2048_best_roguelike', best); }

  if(spawnRandom()){
     setMessage('Move successful!');
  }
  
  moves++;
  render();
  checkEnd();
}

function checkEnd(){
  if (!canMove()){
    render();
    endGame('Game Over', 'You scored ' + score + ' points in ' + moves + ' moves.');
  }
}

function endGame(title, text){
  gameOver = true;
  disableInput();
  if (score > best){ best = score; localStorage.setItem('rogue2048_best_roguelike', best); }
  overlayTitle.textContent = title;
  overlayText.textContent = text + ' (Best: ' + best + ')';
  endgameOverlay.style.display = 'flex';
}

// --- Roguelike Event Logic ---

function showEvent(triggerValue) {
  isEventActive = true;
  disableInput();
  eventTriggerValueEl.textContent = triggerValue;
  eventOptionsEl.innerHTML = '';

  const options = getRandomEventOptions(triggerValue);
  options.forEach((opt, index) => {
    const div = document.createElement('div');
    div.className = 'event-option';
    div.innerHTML = `<h3>${opt.title}</h3><p>${opt.description}</p>`;
    div.addEventListener('click', () => {
      applyEventEffect(opt.effect);
      hideOverlays();
      isEventActive = false;
      enableInput();
      render();
    });
    eventOptionsEl.appendChild(div);
  });
  eventOverlay.style.display = 'flex';
}

function getRandomEventOptions(triggerValue){
  const effects = [
    // Positive effects
    { title: "Divine Favor", description: `Spawn a ${triggerValue * 2} tile on the board.`, effect: (g) => { spawnSpecific(g, triggerValue * 2); } },
    { title: "Power Surge", description: "Upgrade all 2 tiles on the board to 4s.", effect: (g) => { upgradeTiles(g, 2, 4); } },
    { title: "Cleansing Wave", description: `Clear all tiles with a value less than ${triggerValue / 2}.`, effect: (g) => { removeTilesBelow(g, triggerValue / 2); } },
    { title: "Score Boost", description: `Gain an extra ${triggerValue * 10} points.`, effect: (g) => { score += triggerValue * 10; setMessage(`Gained ${triggerValue * 10} extra points!`); } },
    // Negative effects
    { title: "Dark Omen", description: `Spawn a ${triggerValue / 2} tile on the board.`, effect: (g) => { spawnSpecific(g, triggerValue / 2); } },
    { title: "Chaos Shuffle", description: "Randomly rearrange all tiles on the board.", effect: (g) => { shuffleGrid(g); } },
    // Mixed effects
    { title: "Tile Split", description: `Split your highest tile of ${triggerValue} into two ${triggerValue / 2} tiles.`, effect: (g) => { splitMaxTile(g, triggerValue); } }
  ];

  const shuffled = effects.sort(() => 0.5 - Math.random());
  return shuffled.slice(0, 3);
}

function applyEventEffect(effect){
  effect(grid);
}

function spawnSpecific(g, value) {
  const empties = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c]===0) empties.push([r,c]);
  if (!empties.length) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  g[r][c] = value;
  setMessage(`Divine Favor: A ${value} tile has appeared!`);
}

function upgradeTiles(g, from, to) {
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c] === from) g[r][c] = to;
  setMessage(`Power Surge: All ${from} tiles are now ${to}s!`);
}

function removeTilesBelow(g, value) {
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c] < value && g[r][c] !== 0) g[r][c] = 0;
  setMessage(`Cleansing Wave: All tiles below ${value} have been removed!`);
}

function shuffleGrid(g) {
  const flattened = g.flat().sort(() => 0.5 - Math.random());
  let k = 0;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) g[r][c] = flattened[k++];
  setMessage('Chaos Shuffle: The board has been rearranged!');
}

function splitMaxTile(g, value) {
  let maxPos = null;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c] === value) maxPos = [r,c];
  
  if (maxPos) {
    const [r, c] = maxPos;
    g[r][c] = value / 2;
    const empties = [];
    for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c]===0) empties.push([r,c]);
    if (empties.length) {
      const [r2, c2] = empties[Math.floor(Math.random()*empties.length)];
      g[r2][c2] = value / 2;
      setMessage(`Tile Split: Your highest tile has been split into two ${value/2}s!`);
    }
  }
}

// --- UI Helpers ---
function setMessage(txt){ messageEl.textContent = txt; }
function hideOverlays(){ endgameOverlay.style.display = 'none'; eventOverlay.style.display = 'none'; }

// --- Input Handling ---
let keyHandler = (e)=>{
  if (isEventActive) return;
  if (['ArrowLeft','ArrowUp','ArrowRight','ArrowDown'].includes(e.key)){
    e.preventDefault();
    const map = {ArrowLeft:0, ArrowUp:1, ArrowRight:2, ArrowDown:3};
    move(map[e.key]);
  }
};
function enableInput(){ window.addEventListener('keydown', keyHandler); }
function disableInput(){ window.removeEventListener('keydown', keyHandler); }

// --- Controls ---
document.getElementById('btnRestart').addEventListener('click', ()=>init());
document.getElementById('overlayRestart').addEventListener('click', ()=>init());
document.getElementById('btnUndo').addEventListener('click', ()=>{
  if (lastState && !gameOver && !isEventActive){ 
    restoreState(lastState); 
    lastState = null; 
    setMessage('Undo successful.'); 
  } else {
    setMessage('No moves to undo.');
  }
});

init();
</script>
</body>
</html>
