<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rogue-2048 — Roguelike Mode</title>
<style>
  :root{
    --bg:#f6f7fb; --panel:#ffffff; --muted:#9aa0a6;
    --board:#bbaaa0; --cell-empty:#ede6dd;
    --accent:#2e7d32; --accent-2:#3a77ff;
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:Inter, "Segoe UI", Roboto, Arial; background:linear-gradient(180deg,#f8fafc,#f1f4f8); display:flex; justify-content:center; padding:28px;
  }

  .container{width:460px; max-width:95%;}

  header{display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;}
  h1{font-size:18px;margin:0;color:#222;}
  .stats{display:flex; gap:8px; align-items:center;}
  .card{background:var(--panel); padding:8px 12px; border-radius:10px; box-shadow:0 4px 14px rgba(18,24,34,0.06); font-size:13px; color:#111; min-width:86px; text-align:center;}

  .board{background:var(--board); padding:12px; border-radius:12px; display:flex; justify-content:center; box-shadow:0 6px 18px rgba(17,24,39,0.06);}
  .grid{display:grid; grid-template-columns:repeat(4,1fr); gap:12px; width:100%; max-width:380px; padding:6px;}
  .cell{aspect-ratio:1/1; border-radius:10px; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:26px; color:#645b51; background:var(--cell-empty); box-shadow: inset 0 -2px 0 rgba(0,0,0,0.03); user-select:none;}
  /* tile colors (simple) */
  .t-2{background:#eee4da; color:#776e65;}
  .t-4{background:#ede0c8; color:#776e65;}
  .t-8{background:#f2b179; color:#fff;}
  .t-16{background:#f59563; color:#fff;}
  .t-32{background:#f67c5f; color:#fff;}
  .t-64{background:#f65e3b; color:#fff;}
  .t-128{background:#edcf72; color:#fff; font-size:20px;}
  .t-256{background:#f2a541; color:#fff; font-size:20px;}
  .t-512{background:#e27c3f; color:#fff; font-size:18px;}
  .t-1024{background:#e05555; color:#fff; font-size:16px;}
  .t-2048{background:#3ccf9e; color:#fff; font-size:16px;}
  .t-large{font-size:18px;}

  .controls{display:flex; gap:8px; margin-top:12px;}
  button{padding:10px 12px; border-radius:10px; border:0; cursor:pointer; font-weight:600;}
  #btnRestart{background:#3a77ff; color:white; flex:1;}
  #btnUndo{background:#e6eef5; color:#174b8a; flex:1;}

  .meta-row{display:flex; justify-content:space-between; align-items:center; margin-top:10px; color:var(--muted); font-size:13px;}
  .small{font-size:12px; color:var(--muted);}

  /* overlays */
  .overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(2,6,23,0.45); z-index:50;
  }
  .panel{background:var(--panel); padding:18px; border-radius:12px; min-width:320px; max-width:92%; box-shadow:0 12px 40px rgba(2,6,23,0.18); text-align:center;}
  .panel h2{margin:0; font-size:18px;}
  .panel p{margin:8px 0 0; color:var(--muted); font-size:14px;}
  .event-options{display:flex; flex-direction:column; gap:10px; margin-top:14px;}
  .event-option{background:#fbfdff; padding:12px; border-radius:10px; border:1px solid #eef3ff; text-align:left; cursor:pointer; transition:transform .08s ease;}
  .event-option:hover{transform:translateY(-3px); box-shadow:0 8px 20px rgba(46,77,255,0.08);}

  /* responsive */
  @media (max-width:420px){
    .grid{gap:8px;}
    .cell{font-size:22px;}
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Rogue-2048</h1>
      <div class="stats">
        <div class="card">Score<br><strong id="score">0</strong></div>
        <div class="card">Best<br><strong id="best">0</strong></div>
      </div>
    </header>

    <div class="board" id="board">
      <div class="grid" id="grid"></div>
    </div>

    <div class="controls">
      <button id="btnRestart">Restart</button>
      <button id="btnUndo">Undo</button>
    </div>

    <div class="meta-row">
      <div class="small">Moves: <strong id="moves">0</strong></div>
      <div class="small">Highest: <strong id="highest">0</strong></div>
    </div>
  </div>

  <!-- Endgame overlay -->
  <div class="overlay" id="endgameOverlay">
    <div class="panel">
      <h2 id="overlayTitle">Game Over</h2>
      <p id="overlayText">You scored X points in Y moves.</p>
      <div style="margin-top:14px;">
        <button id="overlayRestart" style="background:#3a77ff;color:#fff;padding:10px 12px;border-radius:10px;border:0;cursor:pointer;">Restart</button>
      </div>
    </div>
  </div>

  <!-- Event overlay -->
  <div class="overlay" id="eventOverlay">
    <div class="panel">
      <h2>Event Triggered</h2>
      <p id="eventMessage">Your highest tile reached <strong id="eventTriggerValue">X</strong>. Choose one:</p>
      <div class="event-options" id="eventOptions"></div>
    </div>
  </div>

<script>
/* --- Config & State --- */
const SIZE = 4;
let grid = [];
let score = 0;
let best = parseInt(localStorage.getItem('rogue2048_best_roguelike') || '0');
let moves = 0;
let lastState = null;
let gameOver = false;
let isEventActive = false;
let triggeredMultiples = new Set(); // record which multiples of 8 have been used

/* --- DOM --- */
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const movesEl = document.getElementById('moves');
const highestEl = document.getElementById('highest');
const endgameOverlay = document.getElementById('endgameOverlay');
const eventOverlay = document.getElementById('eventOverlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');
const eventOptionsEl = document.getElementById('eventOptions');
const eventTriggerValueEl = document.getElementById('eventTriggerValue');

bestEl.textContent = best;

/* --- Helpers: UI --- */
function createGridUI(){
  gridEl.innerHTML = '';
  for (let i=0;i<SIZE*SIZE;i++){
    const div = document.createElement('div');
    div.className = 'cell';
    gridEl.appendChild(div);
  }
}
function render(){
  const cells = document.querySelectorAll('.cell');
  let maxV = 0;
  cells.forEach((cell,i)=>{
    const r = Math.floor(i/SIZE), c = i%SIZE;
    const v = grid[r][c];
    cell.textContent = v === 0 ? '' : v;
    cell.className = 'cell' + (v ? ' t-' + v : '');
    // add large class if big
    if (v >= 1024) cell.classList.add('t-large');
    if (v > maxV) maxV = v;
  });
  scoreEl.textContent = score;
  bestEl.textContent = best;
  movesEl.textContent = moves;
  highestEl.textContent = maxV;

  // event trigger: whenever maxV >= 8 and is multiple of 8, and not yet triggered
  if (!isEventActive && maxV >= 8 && maxV % 8 === 0 && !triggeredMultiples.has(maxV)){
    triggeredMultiples.add(maxV);
    showEvent(maxV);
  }
}

/* --- Game Init & Random Spawns --- */
function init(){
  createGridUI();
  grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(0));
  score = 0; moves = 0; lastState = null; gameOver = false; isEventActive = false;
  triggeredMultiples = new Set();
  spawnRandom(); spawnRandom();
  render();
  hideOverlays();
  enableInput();
}

function spawnRandom(){
  const empties = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (grid[r][c] === 0) empties.push([r,c]);
  if (!empties.length) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  grid[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}

/* --- State copy / restore for Undo --- */
function copyState(){
  return {
    grid: grid.map(row=>row.slice()),
    score, moves
  };
}
function restoreState(s){
  grid = s.grid.map(row=>row.slice());
  score = s.score;
  moves = s.moves;
  render();
}

/* --- Movement helpers (explicit, no rotation confusion) --- */
function cloneGrid(g){ return g.map(r=>r.slice()); }

function moveLeftProcess(g){
  // returns {newGrid, moved, gained}
  let moved = false;
  let gained = 0;
  const ng = g.map(row => {
    const filtered = row.filter(x=>x!==0);
    const newRow = [];
    for (let i=0;i<filtered.length;i++){
      if (i+1 < filtered.length && filtered[i] === filtered[i+1]){
        const merged = filtered[i]*2;
        newRow.push(merged);
        gained += merged;
        i++; // skip next
      } else {
        newRow.push(filtered[i]);
      }
    }
    while (newRow.length < SIZE) newRow.push(0);
    return newRow;
  });
  // detect movement
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (ng[r][c] !== g[r][c]) moved = true;
  return {newGrid:ng, moved, gained};
}

function transpose(g){
  const ng = Array.from({length:SIZE}, ()=>Array(SIZE).fill(0));
  for (let i=0;i<SIZE;i++) for (let j=0;j<SIZE;j++) ng[i][j] = g[j][i];
  return ng;
}
function reverseRows(g){
  return g.map(row => row.slice().reverse());
}

function move(dir){ // 0: left, 1: up, 2: right, 3: down
  if (gameOver || isEventActive) return;
  lastState = copyState();

  let g = cloneGrid(grid);
  let result;
  if (dir === 0){ // left
    result = moveLeftProcess(g);
    g = result.newGrid;
  } else if (dir === 1){ // up -> transpose, left, transpose
    g = transpose(g);
    result = moveLeftProcess(g);
    g = transpose(result.newGrid);
  } else if (dir === 2){ // right -> reverse rows, left, reverse
    g = reverseRows(g);
    result = moveLeftProcess(g);
    g = reverseRows(result.newGrid);
  } else if (dir === 3){ // down -> transpose, reverse, left, reverse, transpose
    g = transpose(g);
    g = reverseRows(g);
    result = moveLeftProcess(g);
    g = reverseRows(result.newGrid);
    g = transpose(g);
  }

  if (!result || !result.moved){
    // no move
    return;
  }

  grid = g.map(r=>r.slice());
  score += result.gained;
  if (score > best){ best = score; localStorage.setItem('rogue2048_best_roguelike', best); }
  spawnRandom();
  moves++;
  render();
  checkEnd();
}

/* --- End condition --- */
function canMove(){
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      if (grid[r][c] === 0) return true;
      if (r+1 < SIZE && grid[r+1][c] === grid[r][c]) return true;
      if (c+1 < SIZE && grid[r][c+1] === grid[r][c]) return true;
    }
  }
  return false;
}
function checkEnd(){
  if (!canMove()){
    endGame('Game Over', `You scored ${score} points in ${moves} moves.`);
  }
}
function endGame(title,text){
  gameOver = true;
  disableInput();
  if (score > best){ best = score; localStorage.setItem('rogue2048_best_roguelike', best); }
  overlayTitle.textContent = title;
  overlayText.textContent = text + ` (Best: ${best})`;
  endgameOverlay.style.display = 'flex';
}

/* --- Event system: any multiple of 8 (≥8) --- */
function showEvent(triggerValue){
  isEventActive = true;
  disableInput();
  eventTriggerValueEl.textContent = triggerValue;
  eventOptionsEl.innerHTML = '';

  const options = getRandomEventOptions(triggerValue);
  options.forEach((opt) => {
    const div = document.createElement('div');
    div.className = 'event-option';
    div.innerHTML = `<strong>${opt.title}</strong><div style="margin-top:6px;font-size:13px;color:#6b7280;">${opt.description}</div>`;
    div.addEventListener('click', () => {
      applyEventEffect(opt.effect);
      hideOverlays();
      isEventActive = false;
      enableInput();
      render();
    });
    eventOptionsEl.appendChild(div);
  });

  eventOverlay.style.display = 'flex';
}

function getRandomEventOptions(triggerValue){
  // keep effects safe and integer
  const tv = Math.max(8, Math.floor(triggerValue));
  const half = Math.max(2, tv / 2);
  const effects = [
    { title: "Divine Favor", description: `Spawn a ${tv * 2} tile on the board.`, effect: (g) => spawnSpecific(g, tv * 2) },
    { title: "Power Surge", description: "Upgrade all 2 tiles to 4s.", effect: (g) => upgradeTiles(g, 2, 4) },
    { title: "Cleansing Wave", description: `Clear all tiles smaller than ${Math.floor(half)}.`, effect: (g) => removeTilesBelow(g, Math.floor(half)) },
    { title: "Score Boost", description: `Gain an extra ${tv * 10} points.`, effect: (g) => { score += tv * 10; } },
    { title: "Dark Omen", description: `Spawn a ${Math.max(2, Math.floor(half))} tile on the board.`, effect: (g) => spawnSpecific(g, Math.max(2, Math.floor(half))) },
    { title: "Chaos Shuffle", description: "Randomly shuffle all tiles on the board.", effect: (g) => shuffleGrid(g) },
    { title: "Tile Split", description: `Split one ${tv} tile into two ${Math.floor(half)} tiles.`, effect: (g) => splitMaxTile(g, tv) },
  ];
  // pick 3 random unique options
  const shuffled = effects.sort(()=>0.5 - Math.random());
  return shuffled.slice(0,3);
}

function applyEventEffect(effect){
  effect(grid);
}

/* --- Event effect helpers --- */
function spawnSpecific(g, value){
  const empties = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c]===0) empties.push([r,c]);
  if (!empties.length) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  g[r][c] = Math.max(2, Math.floor(value));
  return true;
}
function upgradeTiles(g, from, to){
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c] === from) g[r][c] = to;
}
function removeTilesBelow(g, value){
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c] !== 0 && g[r][c] < value) g[r][c] = 0;
}
function shuffleGrid(g){
  const flat = g.flat().sort(()=>0.5 - Math.random());
  let k = 0;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) g[r][c] = flat[k++];
}
function splitMaxTile(g, value){
  // find a tile equal to value; if none, find highest and split it
  let max = 0; let pos = null;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) {
    if (g[r][c] > max) { max = g[r][c]; pos = [r,c]; }
  }
  if (!pos) return false;
  const r = pos[0], c = pos[1];
  const half = Math.max(2, Math.floor((g[r][c]) / 2));
  g[r][c] = half;
  const empties = [];
  for (let i=0;i<SIZE;i++) for (let j=0;j<SIZE;j++) if (g[i][j] === 0) empties.push([i,j]);
  if (empties.length){
    const [r2,c2] = empties[Math.floor(Math.random()*empties.length)];
    g[r2][c2] = half;
  }
  return true;
}

/* --- overlays & input --- */
function hideOverlays(){
  endgameOverlay.style.display = 'none';
  eventOverlay.style.display = 'none';
}
document.getElementById('btnRestart').addEventListener('click', init);
document.getElementById('overlayRestart').addEventListener('click', init);
document.getElementById('btnUndo').addEventListener('click', ()=>{
  if (lastState && !gameOver && !isEventActive){
    restoreState(lastState);
    lastState = null;
  }
});

/* keyboard */
function handleKey(e){
  if (isEventActive) return;
  const key = e.key;
  if (['ArrowLeft','ArrowUp','ArrowRight','ArrowDown'].includes(key)){
    e.preventDefault();
    const map = {ArrowLeft:0, ArrowUp:1, ArrowRight:2, ArrowDown:3};
    move(map[key]);
  }
}
function enableInput(){ window.addEventListener('keydown', handleKey); }
function disableInput(){ window.removeEventListener('keydown', handleKey); }

/* simple swipe support for mobile (optional) */
(function addSwipe(){
  let startX = 0, startY = 0;
  const threshold = 20;
  window.addEventListener('touchstart', (e)=>{
    if (isEventActive) return;
    const t = e.touches[0];
    startX = t.clientX; startY = t.clientY;
  }, {passive:true});
  window.addEventListener('touchend', (e)=>{
    if (isEventActive) return;
    const t = (e.changedTouches && e.changedTouches[0]) || {};
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;
    if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
    if (Math.abs(dx) > Math.abs(dy)){
      if (dx > 0) move(2); else move(0);
    } else {
      if (dy > 0) move(3); else move(1);
    }
  }, {passive:true});
})();

/* --- Start --- */
init();
</script>
</body>
</html>

