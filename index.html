<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Rogue-2048 Endless</title>
<style>
:root {
  --bg-start: #e0f7fa;
  --bg-end: #f5fcfd;
  --panel: #ffffff;
  --muted: #607d8b;
  --board: #b2ebf2;
  --cell-empty: #e0f2f1;
  --accent: #00bcd4;
  --accent-2: #3f51b5;
  --radius: 12px;
}
* { box-sizing: border-box; }
html, body {
  height: 100%; margin: 0;
  font-family: 'Poppins', sans-serif, "Segoe UI", Roboto, Arial;
  background: linear-gradient(180deg,var(--bg-start),var(--bg-end));
  display: flex; justify-content: center; align-items: flex-start;
  padding: 20px 10px;
  -webkit-font-smoothing: antialiased;
  font-weight: 500;
}
.container { width: 100%; max-width: 460px; }
header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px; }
h1 { font-size: 24px; margin: 0; font-weight: 700; letter-spacing: -0.5px; }
.stats { display: flex; gap: 8px; align-items: center; }
.card {
  background: var(--panel);
  padding: 8px 16px;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(17,24,39,0.06);
  font-size: 14px;
  color: #424242;
  min-width: 90px;
  text-align: center;
  font-weight: 600;
}
.board {
  background: var(--board);
  padding: 16px;
  border-radius: 20px;
  display: flex;
  justify-content: center;
  box-shadow: 0 12px 40px rgba(17,24,39,0.08);
}
.grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  width: 100%;
  max-width: 400px;
  padding: 8px;
}
.cell {
  aspect-ratio: 1/1;
  border-radius: 12px;
  display: flex; align-items:center; justify-content:center;
  font-weight:800; font-size:30px;
  color:#424242;
  background: var(--cell-empty);
  user-select:none;
  transition: all 0.2s ease;
  box-shadow: inset 0 -3px 0 rgba(0,0,0,0.04), 0 2px 4px rgba(0,0,0,0.02);
}
@keyframes pop {
  0% {transform: scale(1);}
  50% {transform: scale(1.1);}
  100% {transform: scale(1);}
}
.cell.merged { animation: pop 0.1s ease-in-out; }
.t-2 {background:#eee4da;color:#776e65;}
.t-4 {background:#ede0c8;color:#776e65;}
.t-8 {background:#f2b179;color:#fff;}
.t-16 {background:#f59563;color:#fff;}
.t-32 {background:#f67c5f;color:#fff;}
.t-64 {background:#f65e3b;color:#fff;}
.t-128 {background:#edcf72;color:#fff;font-size:24px;}
.t-256 {background:#edcc61;color:#fff;font-size:24px;}
.t-512 {background:#edc850;color:#fff;font-size:20px;}
.t-1024 {background:#edc53f;color:#fff;font-size:18px;}
.t-2048 {background:#edc22e;color:#fff;font-size:18px;}
.t-large {font-size:20px;}
.controls { display:flex; gap:10px; margin-top:16px; }
button {
  padding:12px 16px; border-radius:12px; border:0; cursor:pointer;
  font-weight:700; font-size:15px;
  transition: transform .1s, box-shadow .1s;
}
button:active { transform: translateY(2px); box-shadow:none; }
#btnRestart { background: var(--accent-2); color:#fff; flex:1; box-shadow:0 4px 12px rgba(63,81,181,0.3); }
.overlay {
  position:fixed; inset:0;
  display:none; align-items:center; justify-content:center;
  background: rgba(0,0,0,0.4);
  z-index:50;
  backdrop-filter: blur(5px);
}
.panel {
  background: var(--panel);
  padding:24px;
  border-radius:16px;
  min-width:340px;
  max-width:92%;
  box-shadow:0 18px 60px rgba(0,0,0,0.15);
  text-align:center;
}
.panel h2 { margin:0; font-size:24px; font-weight:700; }
.panel p { margin:10px 0 0; color: var(--muted); font-size:15px; }
.event-options {
  display:flex;
  flex-direction:column;
  gap:12px;
  margin-top:20px;
}
.event-option {
  background:#f8f9fa;
  padding:16px;
  border-radius:12px;
  border:1px solid #e9ecef;
  text-align:left;
  cursor:pointer;
  transition: transform .1s, box-shadow .1s, background .2s;
  user-select:none;
}
.event-option:hover {
  transform: translateY(-3px);
  box-shadow:0 12px 30px rgba(63,81,181,0.08);
  background:#ffffff;
}
.event-option strong { color:#3f51b5; font-size:16px; }
.event-option div { margin-top:4px; font-size:13px; color:#607d8b; }
@media (max-width: 420px) {
  .grid { gap:12px; }
  .cell { font-size:26px; }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Rogue-2048 Endless</h1>
    <div class="stats">
      <div class="card">Score: <span id="score">0</span></div>
      <div class="card">Best: <span id="best">0</span></div>
    </div>
  </header>
  <main class="board">
    <div id="grid" class="grid"></div>
  </main>
  <div class="controls">
    <button id="btnRestart">Restart</button>
  </div>
</div>

<!-- 失败结束覆盖层（Endless 没有 2048 Win 判定，只在无路可走时显示） -->
<div id="endgameOverlay" class="overlay">
  <div class="panel">
    <h2 id="overlayTitle"></h2>
    <p id="overlayText"></p>
    <button id="btnRestart2">Restart</button>
  </div>
</div>

<!-- 事件覆盖层 -->
<div id="eventOverlay" class="overlay">
  <div class="panel">
    <h2 id="overlayTitleEvent">事件触发</h2>
    <p id="overlayTextEvent"></p>
    <div id="eventOptions" class="event-options"></div>
    <button id="btnCloseEvent">Close</button>
  </div>
</div>

<script>
/* ========= 基础状态 ========= */
const SIZE = 4;
let grid = [];
let score = 0;
let best = parseInt(localStorage.getItem('rogue2048_best_roguelike') || '0');
let moves = 0;
let gameOver = false;
let isEventActive = false;
let blindMode = false; // 致盲：渲染问号
let triggeredMultiples = new Set(); // 已对哪些 max 值触发过事件

/* ========= DOM ========= */
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const endgameOverlay = document.getElementById('endgameOverlay');
const eventOverlay = document.getElementById('eventOverlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');
const overlayTitleEvent = document.getElementById('overlayTitleEvent');
const overlayTextEvent = document.getElementById('overlayTextEvent');
const eventOptionsEl = document.getElementById('eventOptions');

bestEl.textContent = best;

/* ========= 初始化与渲染 ========= */
function createGridUI() {
  gridEl.innerHTML = '';
  for (let i = 0; i < SIZE * SIZE; i++) {
    const div = document.createElement('div');
    div.className = 'cell';
    gridEl.appendChild(div);
  }
}

function init() {
  createGridUI();
  grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  score = 0; moves = 0; gameOver = false; isEventActive = false;
  triggeredMultiples.clear();
  blindMode = false;
  spawnRandom();
  spawnRandom();
  render();
  hideOverlays();
  enableInput();
}

/* ========= 工具函数 ========= */
function spawnRandom() {
  const empties = [];
  for (let r = 0; r < SIZE; r++)
    for (let c = 0; c < SIZE; c++)
      if (grid[r][c] === 0) empties.push([r, c]);
  if (!empties.length) return false;
  const [r, c] = empties[Math.floor(Math.random() * empties.length)];
  grid[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}

function cloneGrid(g) {
  return g.map(row => row.slice());
}

function moveLeftProcess(g) {
  let moved = false;
  let gained = 0;
  const ng = g.map((row, rr) => {
    const filtered = row.filter(x => x !== 0);
    const newRow = [];
    for (let i = 0; i < filtered.length; i++) {
      if (i + 1 < filtered.length && filtered[i] === filtered[i + 1]) {
        const merged = filtered[i] * 2;
        newRow.push(merged);
        gained += merged;
        i++;
      } else {
        newRow.push(filtered[i]);
      }
    }
    while (newRow.length < SIZE) newRow.push(0);
    return newRow;
  });
  for (let r = 0; r < SIZE; r++)
    for (let c = 0; c < SIZE; c++)
      if (ng[r][c] !== g[r][c]) moved = true;
  return { newGrid: ng, moved, gained };
}

function transpose(g) {
  const ng = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  for (let r = 0; r < SIZE; r++)
    for (let c = 0; c < SIZE; c++)
      ng[r][c] = g[c][r];
  return ng;
}

function reverseRows(g) {
  return g.map(row => row.slice().reverse());
}

/* dir: 0 左 1 下 2 右 3 上 */
function move(dir) {
  if (gameOver || isEventActive) return;
  let g = cloneGrid(grid);
  let result;
  switch (dir) {
    case 0: result = moveLeftProcess(g); g = result.newGrid; break;
    case 3: g = transpose(g); result = moveLeftProcess(g); g = transpose(result.newGrid); break;
    case 2: g = reverseRows(g); result = moveLeftProcess(g); g = reverseRows(result.newGrid); break;
    case 1: g = transpose(g); g = reverseRows(g); result = moveLeftProcess(g);
            g = reverseRows(result.newGrid); g = transpose(g); break;
  }
  if (!result || !result.moved) return;

  grid = g.map(r => r.slice());
  score += result.gained;
  if (score > best) {
    best = score;
    localStorage.setItem('rogue2048_best_roguelike', best);
  }
  // 致盲效果：在你当前逻辑里只持续到下一次 move 前，这里不强制改动。
  blindMode = blindMode; // 占位，若要持续多回合可扩展计数

  spawnRandom();
  moves++;
  render();
  checkEnd();
}

function canMove() {
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (grid[r][c] === 0) return true;
      if (r + 1 < SIZE && grid[r + 1][c] === grid[r][c]) return true;
      if (c + 1 < SIZE && grid[r][c + 1] === grid[r][c]) return true;
    }
  }
  return false;
}

function checkEnd() {
  if (!canMove()) {
    endGame('Game Over', `Score: ${score}, Moves: ${moves}`);
  }
}

function endGame(title, text) {
  gameOver = true;
  disableInput();
  if (score > best) {
    best = score;
    localStorage.setItem('rogue2048_best_roguelike', best);
  }
  overlayTitle.textContent = title;
  overlayText.textContent = text + ` (Best: ${best})`;
  endgameOverlay.style.display = 'flex';
}

/* ========= 渲染 ========= */
function render() {
  const cells = document.querySelectorAll('.cell');
  let maxV = 0;
  for (let r = 0; r < SIZE; r++)
    for (let c = 0; c < SIZE; c++)
      if (grid[r][c] > maxV) maxV = grid[r][c];

  cells.forEach((cell, i) => {
    const r = Math.floor(i / SIZE), c = i % SIZE;
    const v = grid[r][c];
    if (blindMode && v !== 0) {
      cell.textContent = '?';
      cell.className = 'cell t-large';
    } else {
      cell.textContent = v === 0 ? '' : v;
      cell.className = 'cell' + (v ? ' t-' + v : '');
      if (v >= 1024) cell.classList.add('t-large');
    }
  });
  scoreEl.textContent = score;
  bestEl.textContent = best;

  // 事件触发：max >= 8 且是 8 的倍数 & 未触发过
  if (!isEventActive && maxV >= 8 && maxV % 8 === 0 && !triggeredMultiples.has(maxV)) {
    triggeredMultiples.add(maxV);
    showEvent(maxV);
  }
}

/* ========= 事件系统（符合你描述） ========= */
function showEvent(triggerValue) {
  isEventActive = true;
  disableInput();
  overlayTitleEvent.textContent = '事件触发！';
  overlayTextEvent.textContent = `当前最大值：${triggerValue} 请选择你的命运：`;
  eventOptionsEl.innerHTML = '';

  function getMaxTile() {
    let maxTile = 0;
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++)
        if (grid[r][c] > maxTile) maxTile = grid[r][c];
    return maxTile;
  }
  function getMinTile() { // 最小非 0
    let minTile = Infinity;
    for (let r=0;r<SIZE;r++)
      for (let c=0;c<SIZE;c++) {
        const val = grid[r][c];
        if (val !== 0 && val < minTile) minTile = val;
      }
    return minTile === Infinity ? 0 : minTile;
  }
  function getEmptyPositions() {
    const res = [];
    for (let r=0;r<SIZE;r++)
      for (let c=0;c<SIZE;c++)
        if (grid[r][c] === 0) res.push([r,c]);
    return res;
  }
  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }

  // 好事件（随机挑 1）
  const goodEvents = [
    {
      text: '增加一个“当前最大值”新方块',
      action: () => {
        const maxTile = getMaxTile();
        const empties = getEmptyPositions();
        if (empties.length) {
          const [r,c] = empties[Math.floor(Math.random()*empties.length)];
            grid[r][c] = maxTile;
        }
      }
    },
    {
      text: '随机选 2/4/8 中一种，把所有该数字翻倍',
      action: () => {
        const picks = [2,4,8];
        const chosen = picks[Math.floor(Math.random()*picks.length)];
        for (let r=0;r<SIZE;r++)
          for (let c=0;c<SIZE;c++)
            if (grid[r][c] === chosen) grid[r][c] *= 2;
      }
    }
  ];

  // 坏事件（随机挑 1）
  const badEvents = [
    {
      text: '最大值 /2 (向下取整)',
      action: () => {
        const maxTile = getMaxTile();
        for (let r=0;r<SIZE;r++)
          for (let c=0;c<SIZE;c++)
            if (grid[r][c] === maxTile)
              grid[r][c] = Math.floor(grid[r][c]/2);
      }
    },
    {
      text: '所有 4/8/16 /2 (向下取整)',
      action: () => {
        const set = new Set([4,8,16]);
        for (let r=0;r<SIZE;r++)
          for (let c=0;c<SIZE;c++)
            if (set.has(grid[r][c])) grid[r][c] = Math.floor(grid[r][c]/2);
      }
    }
  ];

  // 混乱事件（全部列出供玩家选择）
  const chaosEvents = [
    {
      text: '打乱全部方块位置',
      action: () => {
        const flat = [];
        for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) flat.push(grid[r][c]);
        shuffleArray(flat);
        for (let i=0;i<flat.length;i++)
          grid[Math.floor(i/SIZE)][i%SIZE] = flat[i];
      }
    },
    {
      text: '致盲：隐藏当前所有数字（下次移动后恢复）',
      action: () => {
        blindMode = true;
      }
    },
    {
      text: '全部变成当前最大值',
      action: () => {
        const maxTile = getMaxTile();
        for (let r=0;r<SIZE;r++)
          for (let c=0;c<SIZE;c++)
            grid[r][c] = maxTile;
      }
    },
    {
      text: '全部变成最小非 0 数字',
      action: () => {
        const minTile = getMinTile();
        for (let r=0;r<SIZE;r++)
          for (let c=0;c<SIZE;c++)
            if (grid[r][c] !== 0) grid[r][c] = minTile;
      }
    },
    {
      text: '获得一个 2048（无空位则随机覆盖）',
      action: () => {
        const empties = getEmptyPositions();
        if (empties.length) {
          const [r,c] = empties[Math.floor(Math.random()*empties.length)];
          grid[r][c] = 2048;
        } else {
          const all = [];
          for (let r=0;r<SIZE;r++)
            for (let c=0;c<SIZE;c++) all.push([r,c]);
          const [r,c] = all[Math.floor(Math.random()*all.length)];
          grid[r][c] = 2048;
        }
      }
    },
    {
      text: '全部随机乘以 0.25 / 0.5 / 2 / 4 (>=1)',
      action: () => {
        const factors = [0.25, 0.5, 2, 4];
        const factor = factors[Math.floor(Math.random()*factors.length)];
        for (let r=0;r<SIZE;r++)
          for (let c=0;c<SIZE;c++)
            if (grid[r][c] !== 0)
              grid[r][c] = Math.max(1, Math.floor(grid[r][c] * factor));
      }
    },
    {
      text: '彩蛋：什么都没有发生',
      action: () => {}
    }
  ];

  // 选择一个好事件 & 一个坏事件展示
  const goodEvent = goodEvents[Math.floor(Math.random()*goodEvents.length)];
  const badEvent = badEvents[Math.floor(Math.random()*badEvents.length)];

  function addOption(label, ev) {
    const div = document.createElement('div');
    div.className = 'event-option';
    div.innerHTML = `<strong>${label}</strong><br>${ev.text}`;
    div.onclick = () => {
      ev.action();
      closeEvent();
    };
    eventOptionsEl.appendChild(div);
  }

  addOption('好事件', goodEvent);
  addOption('坏事件', badEvent);
  chaosEvents.forEach((ev, idx) => addOption('混乱 ' + (idx+1), ev));

  eventOverlay.style.display = 'flex';
}

function closeEvent() {
  isEventActive = false;
  // 如果需要致盲持久，可在 move() 中改逻辑；当前只本次之后恢复
  eventOverlay.style.display = 'none';
  enableInput();
  render();
}

function hideOverlays() {
  endgameOverlay.style.display = 'none';
  eventOverlay.style.display = 'none';
}

/* ========= 输入 ========= */
function disableInput() {
  window.removeEventListener('keydown', keyHandler);
  window.removeEventListener('touchstart', touchStartHandler);
  window.removeEventListener('touchmove', touchMoveHandler);
  window.removeEventListener('touchend', touchEndHandler);
}

function enableInput() {
  window.addEventListener('keydown', keyHandler);
  window.addEventListener('touchstart', touchStartHandler, { passive: true });
  window.addEventListener('touchmove', touchMoveHandler, { passive: true });
  window.addEventListener('touchend', touchEndHandler, { passive: true });
}

function keyHandler(e) {
  if (gameOver || isEventActive) return;
  switch(e.key) {
    case 'ArrowLeft': move(0); break;
    case 'ArrowDown': move(1); break;
    case 'ArrowRight': move(2); break;
    case 'ArrowUp': move(3); break;
  }
}

/* 触屏滑动 */
let touchStartX = 0, touchStartY = 0, touchEndX = 0, touchEndY = 0;
function touchStartHandler(e) {
  if (gameOver || isEventActive) return;
  if (e.touches.length === 1) {
    touchStartX = touchEndX = e.touches[0].clientX;
    touchStartY = touchEndY = e.touches[0].clientY;
  }
}
function touchMoveHandler(e) {
  if (gameOver || isEventActive) return;
  if (e.touches.length === 1) {
    touchEndX = e.touches[0].clientX;
    touchEndY = e.touches[0].clientY;
  }
}
function touchEndHandler() {
  if (gameOver || isEventActive) return;
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  if (Math.abs(dx) < 30 && Math.abs(dy) < 30) return;
  if (Math.abs(dx) > Math.abs(dy)) {
    dx > 0 ? move(2) : move(0);
  } else {
    dy > 0 ? move(1) : move(3);
  }
}

document.getElementById('btnRestart').addEventListener('click', () => {
  init();
  endgameOverlay.style.display = 'none';
});
document.getElementById('btnRestart2').addEventListener('click', () => {
  init();
  endgameOverlay.style.display = 'none';
});
document.getElementById('btnCloseEvent').addEventListener('click', () => {
  closeEvent();
});

/* ========= 启动 ========= */
init();
</script>
</body>
</html>