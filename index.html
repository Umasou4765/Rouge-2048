<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rogue-2048 — Roguelike Mode</title>
<style>
  :root{
    --bg-start: #e0f7fa;
    --bg-end: #f5fcfd;
    --panel: #ffffff;
    --muted: #607d8b;
    --board: #b2ebf2;
    --cell-empty: #e0f2f1;
    --accent: #00bcd4;
    --accent-2: #3f51b5;
    --radius: 12px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;}
  body{
    margin:0; font-family: 'Poppins', sans-serif, "Segoe UI", Roboto, Arial;
    background:linear-gradient(180deg,var(--bg-start),var(--bg-end));
    display:flex; justify-content:center; align-items:flex-start; padding:30px;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    overscroll-behavior-y: none;
    font-weight: 500;
  }
  .container{width:460px; max-width:95%;}
  header{display:flex; justify-content:space-between; align-items:center; margin-bottom:14px;}
  h1{font-size:24px;margin:0;color:#212121; font-weight:700; letter-spacing: -0.5px;}
  .stats{display:flex; gap:8px; align-items:center;}
  .card{background:var(--panel); padding:8px 16px; border-radius:12px;
    box-shadow:0 8px 24px rgba(17,24,39,0.06); font-size:14px; color:#424242; min-width:90px; text-align:center; font-weight:600;}
  .board{background:var(--board); padding:16px; border-radius:20px; display:flex; justify-content:center;
          box-shadow:0 12px 40px rgba(17,24,39,0.08);}
  .grid{display:grid; grid-template-columns:repeat(4,1fr); gap:16px; width:100%; max-width:400px; padding:8px;}
  .cell{aspect-ratio:1/1; border-radius:12px; display:flex; align-items:center; justify-content:center;
    font-weight:800; font-size:30px; color:#424242; background:var(--cell-empty); user-select:none;
    transition: all 0.2s ease;
    transform: scale(1);
    box-shadow: inset 0 -3px 0 rgba(0,0,0,0.04), 0 2px 4px rgba(0,0,0,0.02);}
  .cell.merged{animation:pop 0.1s ease-in-out;}
  @keyframes pop {
    0% {transform: scale(1);}
    50% {transform: scale(1.1);}
    100% {transform: scale(1);}
  }
  .t-2{background:#eee4da; color:#776e65;}
  .t-4{background:#ede0c8; color:#776e65;}
  .t-8{background:#f2b179; color:#fff;}
  .t-16{background:#f59563; color:#fff;}
  .t-32{background:#f67c5f; color:#fff;}
  .t-64{background:#f65e3b; color:#fff;}
  .t-128{background:#edcf72; color:#fff; font-size:24px;}
  .t-256{background:#edcc61; color:#fff; font-size:24px;}
  .t-512{background:#edc850; color:#fff; font-size:20px;}
  .t-1024{background:#edc53f; color:#fff; font-size:18px;}
  .t-2048{background:#edc22e; color:#fff; font-size:18px;}
  .t-large{font-size:20px;}
  .controls{display:flex; gap:10px; margin-top:16px;}
  button{padding:12px 16px; border-radius:12px; border:0; cursor:pointer; font-weight:700; font-size:15px; transition: transform 0.1s ease, box-shadow 0.1s ease;}
  button:active{transform: translateY(2px); box-shadow: none;}
  #btnRestart{background:var(--accent-2); color:white; flex:1; box-shadow:0 4px 12px rgba(63,81,181,0.3);}
  #btnUndo{background:#f2faf7; color:#3f51b5; flex:1; border:1px solid #e0e0e0; box-shadow:0 4px 12px rgba(0,0,0,0.05);}
  .overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.4); z-index:50;
    backdrop-filter: blur(5px);
  }
  .panel{background:var(--panel); padding:24px; border-radius:16px; min-width:340px; max-width:92%; box-shadow:0 18px 60px rgba(0,0,0,0.15); text-align:center;}
  .panel h2{margin:0; font-size:24px; font-weight:700; color:#212121;}
  .panel p{margin:10px 0 0; color:var(--muted); font-size:15px;}
  .event-options{display:flex; flex-direction:column; gap:12px; margin-top:20px;}
  .event-option{background:#f8f9fa; padding:16px; border-radius:12px; border:1px solid #e9ecef; text-align:left; cursor:pointer; transition:transform .1s ease, box-shadow .1s ease; user-select:none;}
  .event-option:hover{transform:translateY(-3px); box-shadow:0 12px 30px rgba(63,81,181,0.08);}
  .event-option strong{color:#3f51b5; font-size:16px;}
  .event-option div{margin-top:4px; font-size:13px; color:#607d8b;}
  @media (max-width:420px){
    .grid{gap:12px;}
    .cell{font-size:26px;}
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Rogue-2048</h1>
      <div class="stats">
        <div class="card">Score<br><strong id="score">0</strong></div>
        <div class="card">Best<br><strong id="best">0</strong></div>
      </div>
    </header>
    <div class="board" id="board">
      <div class="grid" id="grid"></div>
    </div>
    <div class="controls">
      <button id="btnRestart">Restart</button>
      <button id="btnUndo">Undo</button>
    </div>
  </div>
  <div class="overlay" id="endgameOverlay">
    <div class="panel">
      <h2 id="overlayTitle">Game Over</h2>
      <p id="overlayText">You scored X points in Y moves.</p>
      <div style="margin-top:20px;">
        <button id="overlayRestart" style="background:var(--accent-2);color:#fff;padding:12px 16px;border-radius:12px;border:0;cursor:pointer;font-weight:700;">Restart</button>
      </div>
    </div>
  </div>
  <div class="overlay" id="eventOverlay">
    <div class="panel">
      <h2 id="eventTitle">Event Triggered</h2>
      <p id="eventMessage">Your highest tile reached <strong id="eventTriggerValue">X</strong>. Choose one:</p>
      <div class="event-options" id="eventOptions"></div>
    </div>
  </div>
<script>
const SIZE = 4;
let grid = [];
let score = 0;
let best = parseInt(localStorage.getItem('rogue2048_best_roguelike') || '0');
let moves = 0;
let lastState = null;
let gameOver = false;
let isEventActive = false;
let triggeredMultiples = new Set();
const IS_TOUCH = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const endgameOverlay = document.getElementById('endgameOverlay');
const eventOverlay = document.getElementById('eventOverlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');
const eventOptionsEl = document.getElementById('eventOptions');
const eventTriggerValueEl = document.getElementById('eventTriggerValue');
const eventTitle = document.getElementById('eventTitle');
bestEl.textContent = best;
function createGridUI(){
  gridEl.innerHTML = '';
  for (let i=0;i<SIZE*SIZE;i++){
    const div = document.createElement('div');
    div.className = 'cell';
    gridEl.appendChild(div);
  }
}
function render(){
  const cells = document.querySelectorAll('.cell');
  let maxV = 0;
  cells.forEach((cell,i)=>{
    const r = Math.floor(i/SIZE), c = i%SIZE;
    const v = grid[r][c];
    cell.textContent = v === 0 ? '' : v;
    cell.className = 'cell' + (v ? ' t-' + v : '');
    if (v >= 1024) cell.classList.add('t-large');
    if (v > maxV) maxV = v;
  });
  scoreEl.textContent = score;
  bestEl.textContent = best;
  if (!isEventActive && maxV >= 8 && maxV % 8 === 0 && !triggeredMultiples.has(maxV)){
    triggeredMultiples.add(maxV);
    showEvent(maxV);
  }
}
function init(){
  createGridUI();
  grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(0));
  score = 0; moves = 0; lastState = null; gameOver = false; isEventActive = false;
  triggeredMultiples = new Set();
  spawnRandom(); spawnRandom();
  render();
  hideOverlays();
  enableInput();
}
function spawnRandom(){
  const empties = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (grid[r][c] === 0) empties.push([r,c]);
  if (!empties.length) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  grid[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}
function copyState(){
  return {
    grid: grid.map(row=>row.slice()),
    score, moves
  };
}
function restoreState(s){
  grid = s.grid.map(row=>row.slice());
  score = s.score;
  moves = s.moves;
  render();
}
function cloneGrid(g){ return g.map(r=>r.slice()); }
function moveLeftProcess(g){
  let moved = false;
  let gained = 0;
  const ng = g.map(row => {
    const filtered = row.filter(x=>x!==0);
    const newRow = [];
    for (let i=0;i<filtered.length;i++){
      if (i+1 < filtered.length && filtered[i] === filtered[i+1]){
        const merged = filtered[i]*2;
        newRow.push(merged);
        gained += merged;
        i++;
      } else {
        newRow.push(filtered[i]);
      }
    }
    while (newRow.length < SIZE) newRow.push(0);
    return newRow;
  });
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (ng[r][c] !== g[r][c]) moved = true;
  return {newGrid:ng, moved, gained};
}
function transpose(g){
  const ng = Array.from({length:SIZE}, ()=>Array(SIZE).fill(0));
  for (let i=0;i<SIZE;i++) for (let j=0;j<SIZE;j++) ng[i][j] = g[j][i];
  return ng;
}
function reverseRows(g){
  return g.map(row => row.slice().reverse());
}
function move(dir){
  if (gameOver || isEventActive) return;
  lastState = copyState();
  let g = cloneGrid(grid);
  let result;
  if (dir === 0){
    result = moveLeftProcess(g);
    g = result.newGrid;
  } else if (dir === 1){
    g = transpose(g);
    result = moveLeftProcess(g);
    g = transpose(result.newGrid);
  } else if (dir === 2){
    g = reverseRows(g);
    result = moveLeftProcess(g);
    g = reverseRows(result.newGrid);
  } else if (dir === 3){
    g = transpose(g);
    g = reverseRows(g);
    result = moveLeftProcess(g);
    g = reverseRows(result.newGrid);
    g = transpose(g);
  }
  if (!result || !result.moved){
    return;
  }
  grid = g.map(r=>r.slice());
  score += result.gained;
  if (score > best){ best = score; localStorage.setItem('rogue2048_best_roguelike', best); }
  spawnRandom();
  moves++;
  render();
  checkEnd();
}
function canMove(){
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      if (grid[r][c] === 0) return true;
      if (r+1 < SIZE && grid[r+1][c] === grid[r][c]) return true;
      if (c+1 < SIZE && grid[r][c+1] === grid[r][c]) return true;
    }
  }
  return false;
}
function checkEnd(){
  if (!canMove()){
    endGame('Game Over', `You scored ${score} points in ${moves} moves.`);
  }
}
function endGame(title,text){
  gameOver = true;
  disableInput();
  if (score > best){ best = score; localStorage.setItem('rogue2048_best_roguelike', best); }
  overlayTitle.textContent = title;
  overlayText.textContent = text + ` (Best: ${best})`;
  endgameOverlay.style.display = 'flex';
}
function showEvent(triggerValue){
  isEventActive = true;
  disableInput();
  eventTriggerValueEl.textContent = triggerValue;
  eventOptionsEl.innerHTML = '';
  eventTitle.textContent = `Event — ${triggerValue}`;
  const options = getThreeEventOptions(triggerValue);
  options.forEach((opt) => {
    const div = document.createElement('div');
    div.className = 'event-option';
    div.innerHTML = `<strong>${opt.title}</strong><div>${opt.description}</div>`;
    div.addEventListener('click', () => {
      opt.effect(grid);
      hideOverlays();
      isEventActive = false;
      enableInput();
      render();
    });
    eventOptionsEl.appendChild(div);
  });
  eventOverlay.style.display = 'flex';
}
function getThreeEventOptions(triggerValue){
  const tv = Math.max(8, Math.floor(triggerValue));
  const half = Math.max(2, Math.floor(tv/2));
  const goodVariants = [
    { title: "Divine Favor", description: `Spawn a ${tv*2} in an empty spot.`, effect: (g)=> spawnSpecific(g, tv*2) },
    { title: "Power Surge", description: `Upgrade all 2 tiles to 4.`, effect: (g)=> upgradeTiles(g, 2, 4) },
    { title: "Cleansing Wave", description: `Remove all tiles with a value less than ${half}.`, effect: (g)=> removeTilesBelow(g, half) },
  ];
  const badVariants = [
    { title: "Dark Omen", description: `Spawn a ${Math.max(2, Math.floor(half))} in a random empty spot.`, effect: (g)=> spawnSpecific(g, Math.max(2, Math.floor(half))) },
    { title: "Heavy Block", description: `Spawn a 4 tile near the center.`, effect: (g)=> spawnSpecificNearCenter(g, 4) },
    { title: "Obscure", description: `Spawn two 2 tiles in random empty spots.`, effect: (g)=> { spawnSpecific(g,2); spawnSpecific(g,2); } },
  ];
  const chaoticVariants = [
    { title: "Chaos Shuffle", description: `Randomly rearrange all tiles.`, effect: (g)=> shuffleGrid(g) },
    { title: "Tile Split", description: `Split the highest value tile into two smaller ones.`, effect: (g)=> splitMaxTile(g, tv) },
    { title: "???", description: `A random effect from the above options.`, effect: (g)=> {
        const pool = [ (gg)=>shuffleGrid(gg), (gg)=>splitMaxTile(gg,tv), (gg)=>spawnSpecific(gg, Math.max(2, Math.floor(tv/2))) ];
        const fn = pool[Math.floor(Math.random()*pool.length)];
        fn(g);
      }
    },
  ];
  const pick = arr => arr[Math.floor(Math.random()*arr.length)];
  return [
    pick(goodVariants),
    pick(badVariants),
    pick(chaoticVariants),
  ];
}
function applyEventEffect(effect){
  effect(grid);
}
function spawnSpecific(g, value){
  const empties = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c]===0) empties.push([r,c]);
  if (!empties.length) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  g[r][c] = Math.max(2, Math.floor(value));
  return true;
}
function spawnSpecificNearCenter(g, value){
  const centerCells = [[1,1],[1,2],[2,1],[2,2]];
  const empties = centerCells.filter(([r,c])=> g[r][c]===0);
  if (empties.length){
    const [r,c] = empties[Math.floor(Math.random()*empties.length)];
    g[r][c] = Math.max(2, Math.floor(value));
    return true;
  }
  return spawnSpecific(g, value);
}
function upgradeTiles(g, from, to){
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c] === from) g[r][c] = to;
}
function removeTilesBelow(g, value){
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (g[r][c] !== 0 && g[r][c] < value) g[r][c] = 0;
}
function shuffleGrid(g){
  const flat = g.flat().sort(()=>0.5 - Math.random());
  let k = 0;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) g[r][c] = flat[k++];
}
function splitMaxTile(g, value){
  let max = 0; let pos = null;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) {
    if (g[r][c] > max) { max = g[r][c]; pos = [r,c]; }
  }
  if (!pos) return false;
  const r = pos[0], c = pos[1];
  const half = Math.max(2, Math.floor((g[r][c]) / 2));
  g[r][c] = half;
  const empties = [];
  for (let i=0;i<SIZE;i++) for (let j=0;j<SIZE;j++) if (g[i][j] === 0) empties.push([i,j]);
  if (empties.length){
    const [r2,c2] = empties[Math.floor(Math.random()*empties.length)];
    g[r2][c2] = half;
  }
  return true;
}
function hideOverlays(){
  endgameOverlay.style.display = 'none';
  eventOverlay.style.display = 'none';
}
document.getElementById('btnRestart').addEventListener('click', init);
document.getElementById('overlayRestart').addEventListener('click', init);
document.getElementById('btnUndo').addEventListener('click', ()=>{
  if (lastState && !gameOver && !isEventActive){
    restoreState(lastState);
    lastState = null;
  }
});
let inputEnabled = false;
function handleKey(e){
  if (isEventActive) return;
  const key = e.key;
  const map = {ArrowLeft:0, ArrowUp:1, ArrowRight:2, ArrowDown:3};
  if (key in map){
    e.preventDefault();
    move(map[key]);
  }
}
function enableInput(){
  if (inputEnabled) return;
  window.addEventListener('keydown', handleKey);
  inputEnabled = true;
}
function disableInput(){
  if (!inputEnabled) return;
  window.removeEventListener('keydown', handleKey);
  inputEnabled = false;
}
if (IS_TOUCH){
  (function addSwipe(){
    let startX = 0, startY = 0;
    const threshold = 20;
    window.addEventListener('touchstart', (e)=>{
      if (isEventActive) return;
      const t = e.touches[0];
      startX = t.clientX; startY = t.clientY;
    }, {passive:true});
    window.addEventListener('touchend', (e)=>{
      if (isEventActive) return;
      const t = (e.changedTouches && e.changedTouches[0]) || {};
      const dx = t.clientX - startX;
      const dy = t.clientY - startY;
      if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
      if (Math.abs(dx) > Math.abs(dy)){
        if (dx > 0) move(2); else move(0);
      } else {
        if (dy > 0) move(3); else move(1);
      }
    }, {passive:true});
  })();
}
init();
</script>
</body>
</html>
