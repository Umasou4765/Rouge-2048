<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Rogue-2048</title>
<style>
:root {
  --bg-start: #e0f7fa;
  --bg-end: #f5fcfd;
  --panel: #ffffff;
  --muted: #607d8b;
  --board: #b2ebf2;
  --cell-empty: #e0f2f1;
  --accent: #00bcd4;
  --accent-2: #3f51b5;
  --radius: 12px;
}
* {
  box-sizing: border-box;
}
html, body {
  height: 100%;
  margin: 0;
  font-family: 'Poppins', sans-serif, "Segoe UI", Roboto, Arial;
  background: linear-gradient(180deg, var(--bg-start), var(--bg-end));
  display: flex;
  justify-content: center;
  align-items: flex-start;
  padding: 20px 10px;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  overscroll-behavior-y: none;
  font-weight: 500;
}
.container {
  width: 100%;
  max-width: 460px;
}
header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 14px;
}
h1 {
  font-size: 24px;
  margin: 0;
  color: #212121;
  font-weight: 700;
  letter-spacing: -0.5px;
}
.stats {
  display: flex;
  gap: 8px;
  align-items: center;
}
.card {
  background: var(--panel);
  padding: 8px 16px;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(17,24,39,0.06);
  font-size: 14px;
  color: #424242;
  min-width: 90px;
  text-align: center;
  font-weight: 600;
}
.board {
  background: var(--board);
  padding: 16px;
  border-radius: 20px;
  display: flex;
  justify-content: center;
  box-shadow: 0 12px 40px rgba(17,24,39,0.08);
}
.grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
  width: 100%;
  max-width: 400px;
  padding: 8px;
}
.cell {
  aspect-ratio: 1 / 1;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  font-size: 30px;
  color: #424242;
  background: var(--cell-empty);
  user-select: none;
  transition: all 0.2s ease;
  transform: scale(1);
  box-shadow: inset 0 -3px 0 rgba(0,0,0,0.04), 0 2px 4px rgba(0,0,0,0.02);
}
.cell.merged {
  animation: pop 0.1s ease-in-out;
}
@keyframes pop {
  0% {transform: scale(1);}
  50% {transform: scale(1.1);}
  100% {transform: scale(1);}
}
.t-2 {background: #eee4da; color: #776e65;}
.t-4 {background: #ede0c8; color: #776e65;}
.t-8 {background: #f2b179; color: #fff;}
.t-16 {background: #f59563; color: #fff;}
.t-32 {background: #f67c5f; color: #fff;}
.t-64 {background: #f65e3b; color: #fff;}
.t-128 {background: #edcf72; color: #fff; font-size: 24px;}
.t-256 {background: #edcc61; color: #fff; font-size: 24px;}
.t-512 {background: #edc850; color: #fff; font-size: 20px;}
.t-1024 {background: #edc53f; color: #fff; font-size: 18px;}
.t-2048 {background: #edc22e; color: #fff; font-size: 18px;}
.t-large {font-size: 20px;}
.controls {
  display: flex;
  gap: 10px;
  margin-top: 16px;
}
button {
  padding: 12px 16px;
  border-radius: 12px;
  border: 0;
  cursor: pointer;
  font-weight: 700;
  font-size: 15px;
  transition: transform 0.1s ease, box-shadow 0.1s ease;
}
button:active {
  transform: translateY(2px);
  box-shadow: none;
}
#btnRestart {
  background: var(--accent-2);
  color: white;
  flex: 1;
  box-shadow: 0 4px 12px rgba(63,81,181,0.3);
}
.overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.4);
  z-index: 50;
  backdrop-filter: blur(5px);
}
.panel {
  background: var(--panel);
  padding: 24px;
  border-radius: 16px;
  min-width: 340px;
  max-width: 92%;
  box-shadow: 0 18px 60px rgba(0,0,0,0.15);
  text-align: center;
}
.panel h2 {
  margin: 0;
  font-size: 24px;
  font-weight: 700;
  color: #212121;
}
.panel p {
  margin: 10px 0 0;
  color: var(--muted);
  font-size: 15px;
}
.event-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 20px;
}
.event-option {
  background: #f8f9fa;
  padding: 16px;
  border-radius: 12px;
  border: 1px solid #e9ecef;
  text-align: left;
  cursor: pointer;
  transition: transform .1s ease, box-shadow .1s ease;
  user-select: none;
}
.event-option:hover {
  transform: translateY(-3px);
  box-shadow: 0 12px 30px rgba(63,81,181,0.08);
}
.event-option strong {
  color: #3f51b5;
  font-size: 16px;
}
.event-option div {
  margin-top: 4px;
  font-size: 13px;
  color: #607d8b;
}
@media (max-width: 420px) {
  .grid {
    gap: 12px;
  }
  .cell {
    font-size: 26px;
  }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Rogue-2048</h1>
    <div class="stats">
      <div class="card">Score: <span id="score">0</span></div>
      <div class="card">Best: <span id="best">0</span></div>
    </div>
  </header>
  <main class="board">
    <div id="grid" class="grid"></div>
  </main>
  <div class="controls">
    <button id="btnRestart">Restart</button>
  </div>
</div>

<div id="endgameOverlay" class="overlay">
  <div class="panel">
    <h2 id="overlayTitle"></h2>
    <p id="overlayText"></p>
    <button id="btnRestart2">Restart</button>
  </div>
</div>

<div id="eventOverlay" class="overlay">
  <div class="panel">
    <h2 id="overlayTitleEvent">Event</h2>
    <p id="overlayTextEvent"></p>
    <div id="eventOptions" class="event-options"></div>
    <button id="btnCloseEvent">Close</button>
  </div>
</div>

<script>
const SIZE = 4;
let grid = [];
let score = 0;
let best = parseInt(localStorage.getItem('rogue2048_best_roguelike') || '0');
let moves = 0;
let gameOver = false;
let isEventActive = false;
let triggeredMultiples = new Set();
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const endgameOverlay = document.getElementById('endgameOverlay');
const eventOverlay = document.getElementById('eventOverlay');
const overlayTitle = document.getElementById('overlayTitle');
const overlayText = document.getElementById('overlayText');
const eventOptionsEl = document.getElementById('eventOptions');
const overlayTitleEvent = document.getElementById('overlayTitleEvent');
const overlayTextEvent = document.getElementById('overlayTextEvent');

bestEl.textContent = best;
let blindMode = false;

function createGridUI() {
  gridEl.innerHTML = '';
  for (let i = 0; i < SIZE * SIZE; i++) {
    const div = document.createElement('div');
    div.className = 'cell';
    gridEl.appendChild(div);
  }
}

function render() {
  const cells = document.querySelectorAll('.cell');
  let maxV = 0;
  cells.forEach((cell, i) => {
    const r = Math.floor(i / SIZE), c = i % SIZE;
    const v = grid[r][c];
    if (blindMode && v !== 0) {
      cell.textContent = '?';
      cell.className = 'cell t-large';
    } else {
      cell.textContent = v === 0 ? '' : v;
      cell.className = 'cell' + (v ? ' t-' + v : '');
      if (v >= 1024) cell.classList.add('t-large');
    }
    if (v > maxV) maxV = v;
  });
  scoreEl.textContent = score;
  bestEl.textContent = best;

  if (!isEventActive && maxV >= 8 && maxV % 8 === 0 && !triggeredMultiples.has(maxV)) {
    triggeredMultiples.add(maxV);
    showEvent(maxV);
  }
}

function init() {
  createGridUI();
  grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  score = 0; moves = 0; gameOver = false; isEventActive = false;
  triggeredMultiples.clear();
  blindMode = false;
  spawnRandom();
  spawnRandom();
  render();
  hideOverlays();
  enableInput();
}

function spawnRandom() {
  const empties = [];
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (grid[r][c] === 0) empties.push([r, c]);
    }
  }
  if (!empties.length) return false;
  const [r, c] = empties[Math.floor(Math.random() * empties.length)];
  grid[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}

function cloneGrid(g) {
  return g.map(row => row.slice());
}

function moveLeftProcess(g) {
  let moved = false;
  let gained = 0;
  const ng = g.map(row => {
    const filtered = row.filter(x => x !== 0);
    const newRow = [];
    for (let i = 0; i < filtered.length; i++) {
      if (i + 1 < filtered.length && filtered[i] === filtered[i + 1]) {
        const merged = filtered[i] * 2;
        newRow.push(merged);
        gained += merged;
        i++;
      } else {
        newRow.push(filtered[i]);
      }
    }
    while (newRow.length < SIZE) newRow.push(0);
    return newRow;
  });
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (ng[r][c] !== g[r][c]) moved = true;
    }
  }
  return { newGrid: ng, moved, gained };
}

function transpose(g) {
  const ng = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  for (let i = 0; i < SIZE; i++) for (let j = 0; j < SIZE; j++) ng[i][j] = g[j][i];
  return ng;
}

function reverseRows(g) {
  return g.map(row => row.slice().reverse());
}

function move(dir) {
  if (gameOver || isEventActive) return;
  let g = cloneGrid(grid);
  let result;

  switch (dir) {
    case 0:
      result = moveLeftProcess(g);
      g = result.newGrid;
      break;
    case 3:
      g = transpose(g);
      result = moveLeftProcess(g);
      g = transpose(result.newGrid);
      break;
    case 2:
      g = reverseRows(g);
      result = moveLeftProcess(g);
      g = reverseRows(result.newGrid);
      break;
    case 1:
      g = transpose(g);
      g = reverseRows(g);
      result = moveLeftProcess(g);
      g = reverseRows(result.newGrid);
      g = transpose(g);
      break;
  }

  if (!result || !result.moved) return;

  grid = g.map(r => r.slice());
  score += result.gained;
  if (score > best) {
    best = score;
    localStorage.setItem('rogue2048_best_roguelike', best);
  }
  blindMode = false;
  spawnRandom();
  moves++;
  render();
  checkEnd();
}

function canMove() {
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (grid[r][c] === 0) return true;
      if (r + 1 < SIZE && grid[r + 1][c] === grid[r][c]) return true;
      if (c + 1 < SIZE && grid[r][c + 1] === grid[r][c]) return true;
    }
  }
  return false;
}

function checkEnd() {
  if (!canMove()) {
    endGame('Game Over', `You scored ${score} points in ${moves} moves.`);
  }
}

function endGame(title, text) {
  gameOver = true;
  disableInput();
  if (score > best) {
    best = score;
    localStorage.setItem('rogue2048_best_roguelike', best);
  }
  overlayTitle.textContent = title;
  overlayText.textContent = text + ` (Best: ${best})`;
  endgameOverlay.style.display = 'flex';
}

function showEvent(triggerValue) {
  isEventActive = true;
  disableInput();
  overlayTitleEvent.textContent = 'Event Triggered!';
  overlayTextEvent.textContent = `Your max tile is ${triggerValue}. Choose your fate:`;
  eventOptionsEl.innerHTML = '';

  const options = [
    { label: 'Good', desc: 'Gain +score bonus and reset board.', action: () => {
      score += triggerValue * 10;
      grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
      spawnRandom();
      spawnRandom();
      blindMode = false;
      closeEvent();
    }},
    { label: 'Bad', desc: 'Lose some points and add a 16 tile.', action: () => {
      score = Math.max(0, score - triggerValue * 5);
      let placed = false;
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (grid[r][c] === 0) {
            grid[r][c] = 16;
            placed = true;
            break;
          }
        }
        if (placed) break;
      }
      closeEvent();
    }},
    { label: 'Chaos', desc: 'Shuffle all tiles randomly.', action: () => {
      const values = [];
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          if (grid[r][c] !== 0) values.push(grid[r][c]);
        }
      }
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          grid[r][c] = 0;
        }
      }
      for (let val of values) {
        let placed = false;
        while (!placed) {
          const rr = Math.floor(Math.random() * SIZE);
          const cc = Math.floor(Math.random() * SIZE);
          if (grid[rr][cc] === 0) {
            grid[rr][cc] = val;
            placed = true;
          }
        }
      }
      closeEvent();
    }}
  ];

  options.forEach(({label, desc, action}) => {
    const div = document.createElement('div');
    div.className = 'event-option';
    div.innerHTML = `<strong>${label}</strong><div>${desc}</div>`;
    div.addEventListener('click', action);
    eventOptionsEl.appendChild(div);
  });

  eventOverlay.style.display = 'flex';
  render();
}

function closeEvent() {
  isEventActive = false;
  eventOverlay.style.display = 'none';
  render();
  enableInput();
}

function hideOverlays() {
  endgameOverlay.style.display = 'none';
  eventOverlay.style.display = 'none';
}

function disableInput() {
  window.removeEventListener('keydown', keyHandler);
  window.removeEventListener('touchstart', touchStartHandler);
  window.removeEventListener('touchmove', touchMoveHandler);
  window.removeEventListener('touchend', touchEndHandler);
}

function enableInput() {
  window.addEventListener('keydown', keyHandler);
  window.addEventListener('touchstart', touchStartHandler, { passive: true });
  window.addEventListener('touchmove', touchMoveHandler, { passive: true });
  window.addEventListener('touchend', touchEndHandler, { passive: true });
}

function keyHandler(e) {
  if (gameOver || isEventActive) return;
  switch(e.key) {
    case 'ArrowLeft': move(0); break;
    case 'ArrowDown': move(1); break;
    case 'ArrowRight': move(2); break;
    case 'ArrowUp': move(3); break;
  }
}

let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

function touchStartHandler(e) {
  if (gameOver || isEventActive) return;
  if (e.touches.length === 1) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchEndX = touchStartX;
    touchEndY = touchStartY;
  }
}
function touchMoveHandler(e) {
  if (gameOver || isEventActive) return;
  if (e.touches.length === 1) {
    touchEndX = e.touches[0].clientX;
    touchEndY = e.touches[0].clientY;
  }
}
function touchEndHandler(e) {
  if (gameOver || isEventActive) return;
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx < 30 && absDy < 30) return;

  if (absDx > absDy) {
    if (dx > 0) move(2);
    else move(0);
  } else {
    if (dy > 0) move(1);
    else move(3);
  }

  touchStartX = 0;
  touchStartY = 0;
  touchEndX = 0;
  touchEndY = 0;
}

document.getElementById('btnRestart').addEventListener('click', () => {
  init();
  endgameOverlay.style.display = 'none';
});
document.getElementById('btnRestart2').addEventListener('click', () => {
  init();
  endgameOverlay.style.display = 'none';
});
document.getElementById('btnCloseEvent').addEventListener('click', () => {
  closeEvent();
});

init();
</script>
</body>
</html>
